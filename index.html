<!DOCTYPE html>
<!-- GitHub: https://github.com/doublejosh/Eyes -->
<!-- Press Space bar for help -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eyes</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .eyes-container {
            display: flex;
            gap: 20vw;
            align-items: center;
            transform: scale(1) translate(0, 0);
            transition: transform 0.3s ease-out, gap 0.3s ease-out;
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
        }

        .eyes-container.hidden {
            display: none;
        }

        .eye {
            width: 200px;
            height: 120px;
            cursor: pointer;
            transition: transform 0.1s ease-out;
        }

        .eye.blinking {
            transform: scaleY(0.1);
        }

        .iris {
            transition: transform 1.5s ease-out;
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            color: #ccc;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 300px;
            display: none;
        }

        .instructions.visible {
            display: block;
        }

        .instructions h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
        }

        .instructions p {
            margin: 8px 0;
        }

        .instructions kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        .help-message {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 60px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            pointer-events: none;
            z-index: 1000;
        }

        .help-message.visible {
            opacity: 1;
        }

        .spider-grid {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            grid-template-columns: repeat(14, 60px);
            row-gap: -8px;
            column-gap: 8px;
            padding: 20px;
        }

        .spider-grid.active {
            display: grid;
        }

        .spider-eye {
            width: 60px;
            height: 60px;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .spider-eye.blinking {
            transform: scaleY(0.7);
        }

        /* Offset every other row (rows 2, 4, 6, 8, 10, 12, 14) */
        .spider-eye:nth-child(n+15):nth-child(-n+28),
        .spider-eye:nth-child(n+43):nth-child(-n+56),
        .spider-eye:nth-child(n+71):nth-child(-n+84),
        .spider-eye:nth-child(n+99):nth-child(-n+112),
        .spider-eye:nth-child(n+127):nth-child(-n+140),
        .spider-eye:nth-child(n+155):nth-child(-n+168),
        .spider-eye:nth-child(n+183):nth-child(-n+196) {
            margin-left: 30px;
        }

        /* Hide corner eyes to make circular shape for 14x14 grid */
        /* Row 1: hide outer corners */
        .spider-eye:nth-child(1),
        .spider-eye:nth-child(2),
        .spider-eye:nth-child(3),
        .spider-eye:nth-child(4),
        .spider-eye:nth-child(12),
        .spider-eye:nth-child(13),
        .spider-eye:nth-child(14),
        /* Row 2: hide corners */
        .spider-eye:nth-child(15),
        .spider-eye:nth-child(16),
        .spider-eye:nth-child(27),
        .spider-eye:nth-child(28),
        /* Row 3: hide corners */
        .spider-eye:nth-child(29),
        .spider-eye:nth-child(30),
        .spider-eye:nth-child(42),
        /* Row 4: hide corners */
        .spider-eye:nth-child(43),
        .spider-eye:nth-child(56),
        /* Row 11: hide corners */
        .spider-eye:nth-child(141),
        /* Row 12: hide corners */
        .spider-eye:nth-child(155),
        .spider-eye:nth-child(167),
        .spider-eye:nth-child(168),
        /* Row 13: hide corners */
        .spider-eye:nth-child(169),
        .spider-eye:nth-child(170),
        .spider-eye:nth-child(181),
        .spider-eye:nth-child(182),
        /* Row 14: hide corners */
        .spider-eye:nth-child(183),
        .spider-eye:nth-child(184),
        .spider-eye:nth-child(185),
        .spider-eye:nth-child(194),
        .spider-eye:nth-child(195),
        .spider-eye:nth-child(196),
        /* Row 15: hide orphaned eyes */
        .spider-eye:nth-child(197),
        .spider-eye:nth-child(198),
        .spider-eye:nth-child(199),
        .spider-eye:nth-child(200) {
            visibility: hidden;
        }

        #eyes-stage.spider-mode-active {
            display: none;
        }

        @keyframes colorShift1 {
            0% { stop-color: #4CAF50; }      /* Light Green */
            16.67% { stop-color: #D2691E; }  /* Saddle Brown */
            33.33% { stop-color: #6495ED; }  /* Cornflower Blue */
            50% { stop-color: #FFB347; }     /* Light Orange */
            66.67% { stop-color: #F08080; }  /* Light Coral */
            83.33% { stop-color: #FFB6C1; }  /* Light Pink */
            100% { stop-color: #4CAF50; }    /* Back to Light Green */
        }

        @keyframes colorShift2 {
            0% { stop-color: #388E3C; }      /* Medium Green */
            16.67% { stop-color: #A0522D; }  /* Sienna */
            33.33% { stop-color: #4169E1; }  /* Royal Blue */
            50% { stop-color: #FF8C00; }     /* Dark Orange */
            66.67% { stop-color: #DC143C; }  /* Crimson */
            83.33% { stop-color: #FF69B4; }  /* Hot Pink */
            100% { stop-color: #388E3C; }    /* Back to Medium Green */
        }

        @keyframes colorShift3 {
            0% { stop-color: #2E7D32; }      /* Dark Green */
            16.67% { stop-color: #8B4513; }  /* Saddle Brown */
            33.33% { stop-color: #1E90FF; }  /* Dodge Blue */
            50% { stop-color: #FF7F00; }     /* Orange */
            66.67% { stop-color: #B22222; }  /* Fire Brick */
            83.33% { stop-color: #C71585; }  /* Medium Violet Red */
            100% { stop-color: #2E7D32; }    /* Back to Dark Green */
        }

        @keyframes colorShift4 {
            0% { stop-color: #1B5E20; }      /* Very Dark Green */
            16.67% { stop-color: #654321; }  /* Dark Brown */
            33.33% { stop-color: #000080; }  /* Navy */
            50% { stop-color: #CC5500; }     /* Burnt Orange */
            66.67% { stop-color: #800020; }  /* Burgundy */
            83.33% { stop-color: #8B008B; }  /* Dark Magenta */
            100% { stop-color: #1B5E20; }    /* Back to Very Dark Green */
        }

        @keyframes colorShift {
            0% { fill: #8b0000; }      /* Dark Red */
            16.67% { fill: #4a0000; }  /* Darker Red */
            33.33% { fill: #660000; }  /* Blood Red */
            50% { fill: #8b0000; }     /* Dark Red */
            66.67% { fill: #a00000; }  /* Crimson */
            83.33% { fill: #660000; }  /* Blood Red */
            100% { fill: #8b0000; }    /* Back to Dark Red */
        }

        @keyframes eyePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.16); }
        }

        @keyframes eyeBlink {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.85); }
        }

        /* Drip container and animations */
        #drips-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .drip {
            position: absolute;
            background: var(--drip-color, #7a9b3d);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            opacity: 0;
            filter: blur(1px);
            pointer-events: none;
        }

        .drip.active {
            animation: dripFall var(--drip-duration, 2s) ease-in forwards;
        }

        @keyframes dripFall {
            0% {
                opacity: 0.7;
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scaleY(1);
            }
            20% {
                opacity: 0.8;
                transform: translate(calc(var(--start-x, 0) + var(--drift-x, 0px)), calc(var(--start-y, 0) + 30px)) scaleY(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--start-x, 0) + var(--drift-x, 0px)), calc(var(--start-y, 0) + var(--fall-distance, 200px))) scaleY(2);
            }
        }

    </style>
</head>
<body>
    <div id="eyes-stage"></div>

    <div id="spider-stage" class="spider-grid"></div>

    <div id="drips-container"></div>

    <div class="help-message" id="help-message">Space bar for help</div>

    <div class="instructions" id="instructions">
        <h3>Controls</h3>
        <p><kbd>C</kbd> Auto creepy (beast mode)</p>
        <p><kbd>X</kbd> Eye tracking (beast mode)</p>
        <p><kbd>Z</kbd> Custom eyes</p>
        <p><kbd>1-0</kbd> Toggle eye sets (10)</p>
        <p><kbd>Q/W</kbd> Scale up/down</p>
        <p><kbd>E/R</kbd> Gap wider/closer</p>
        <p><kbd>↑↓←→</kbd> Move position</p>
        <p><kbd>Space</kbd> Help</p>
    </div>

    <script>
        // Create single spider eye HTML dynamically
        function createSpiderEye(eyeId) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'spider-eye');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('data-eye-id', eyeId);

            svg.innerHTML = `
                <!-- Eye white (circular) with bloodshot veins -->
                <circle cx="50" cy="50" r="48" fill="#fff8f0" stroke="#8b0000" stroke-width="2"/>

                <!-- Blood vessels -->
                <path d="M 50 2 Q 45 20, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 50 98 Q 55 80, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 2 50 Q 20 45, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 98 50 Q 80 55, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 15 15 Q 30 30, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 85 85 Q 70 70, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 85 15 Q 70 30, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 15 85 Q 30 70, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>

                <!-- Iris group -->
                <g class="iris">
                    <!-- Large menacing iris with dark red color -->
                    <circle class="iris-main" cx="50" cy="50" r="24" fill="#8b0000" stroke="#4a0000" stroke-width="2"/>
                </g>

                <!-- Black pupil (dilated for menacing effect) -->
                <g class="iris">
                    <circle cx="50" cy="50" r="14" fill="#000"/>
                    <!-- Sinister glint -->
                    <circle cx="45" cy="45" r="2" fill="rgba(255,255,255,0.7)"/>
                </g>
            `;

            return svg;
        }

        // Create eye pair HTML dynamically
        function createEyePair(setId) {
            const container = document.createElement('div');
            container.className = 'eyes-container';
            container.setAttribute('data-set-id', setId);

            container.innerHTML = `
        <!-- Left Eye -->
        <svg class="eye" viewBox="0 0 200 120">
            <!-- Gradients and filters for realistic iris -->
            <defs>
                <radialGradient id="irisGradient1-${setId}" cx="0.3" cy="0.3" r="0.7">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#4CAF50" stop-opacity="0.8"/>
                    <stop class="iris-gradient-stop-2" offset="30%" stop-color="#388E3C" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-3" offset="70%" stop-color="#2E7D32" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#1B5E20" stop-opacity="0.8"/>
                </radialGradient>
                <radialGradient id="irisGradient2-${setId}" cx="0.7" cy="0.4" r="0.6">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#66BB6A" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-2" offset="50%" stop-color="#43A047" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#2E7D32" stop-opacity="0.7"/>
                </radialGradient>
                <radialGradient id="irisGradient3-${setId}" cx="0.5" cy="0.7" r="0.5">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#81C784" stop-opacity="0.5"/>
                    <stop class="iris-gradient-stop-2" offset="60%" stop-color="#4CAF50" stop-opacity="0.3"/>
                    <stop class="iris-gradient-stop-3" offset="100%" stop-color="#388E3C" stop-opacity="0.6"/>
                </radialGradient>
                <filter id="irisBlur-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="1"/>
                </filter>
                <filter id="irisBlur2-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2"/>
                </filter>
            </defs>
            <!-- Eye white (outer oval) -->
            <ellipse class="eye-white" cx="100" cy="60" rx="95" ry="55" fill="white" stroke="#ddd" stroke-width="2"/>

            <!-- Green iris -->
            <g class="iris">
                <!-- Base iris with color-changing gradient -->
                <ellipse class="iris-main" cx="100" cy="60" rx="35" ry="35" fill="#228B22" stroke="#1F5F1F" stroke-width="1"/>
                <!-- Overlapping gradient clouds for texture -->
                <ellipse cx="95" cy="55" rx="28" ry="28" fill="url(#irisGradient1-${setId})" filter="url(#irisBlur-${setId})"/>
                <ellipse cx="105" cy="58" rx="25" ry="25" fill="url(#irisGradient2-${setId})" filter="url(#irisBlur-${setId})"/>
                <ellipse cx="100" cy="65" rx="22" ry="22" fill="url(#irisGradient3-${setId})" filter="url(#irisBlur2-${setId})"/>
                <!-- Additional texture layers -->
                <ellipse cx="92" cy="62" rx="15" ry="15" fill="url(#irisGradient1-${setId})" filter="url(#irisBlur2-${setId})" opacity="0.4"/>
                <ellipse cx="108" cy="55" rx="18" ry="18" fill="url(#irisGradient2-${setId})" filter="url(#irisBlur-${setId})" opacity="0.5"/>
            </g>

            <!-- Black pupil -->
            <g class="iris">
                <ellipse cx="100" cy="60" rx="15" ry="15" fill="#000"/>
                <!-- Lens flare inside pupil -->
                <ellipse cx="95" cy="55" rx="3" ry="4" fill="rgba(255,255,255,0.9)"/>
                <ellipse cx="92" cy="52" rx="1.5" ry="1.5" fill="rgba(255,255,255,0.7)"/>
            </g>
        </svg>

        <!-- Right Eye -->
        <svg class="eye" viewBox="0 0 200 120">
            <!-- Gradients and filters for realistic iris -->
            <defs>
                <radialGradient id="irisGradient1Right-${setId}" cx="0.3" cy="0.3" r="0.7">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#4CAF50" stop-opacity="0.8"/>
                    <stop class="iris-gradient-stop-2" offset="30%" stop-color="#388E3C" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-3" offset="70%" stop-color="#2E7D32" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#1B5E20" stop-opacity="0.8"/>
                </radialGradient>
                <radialGradient id="irisGradient2Right-${setId}" cx="0.7" cy="0.4" r="0.6">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#66BB6A" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-2" offset="50%" stop-color="#43A047" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#2E7D32" stop-opacity="0.7"/>
                </radialGradient>
                <radialGradient id="irisGradient3Right-${setId}" cx="0.5" cy="0.7" r="0.5">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#81C784" stop-opacity="0.5"/>
                    <stop class="iris-gradient-stop-2" offset="60%" stop-color="#4CAF50" stop-opacity="0.3"/>
                    <stop class="iris-gradient-stop-3" offset="100%" stop-color="#388E3C" stop-opacity="0.6"/>
                </radialGradient>
                <filter id="irisBlurRight-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="1"/>
                </filter>
                <filter id="irisBlur2Right-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2"/>
                </filter>
            </defs>
            <!-- Eye white (outer oval) -->
            <ellipse class="eye-white" cx="100" cy="60" rx="95" ry="55" fill="white" stroke="#ddd" stroke-width="2"/>

            <!-- Green iris -->
            <g class="iris">
                <!-- Base iris with color-changing gradient -->
                <ellipse class="iris-main" cx="100" cy="60" rx="35" ry="35" fill="#228B22" stroke="#1F5F1F" stroke-width="1"/>
                <!-- Overlapping gradient clouds for texture -->
                <ellipse cx="95" cy="55" rx="28" ry="28" fill="url(#irisGradient1Right-${setId})" filter="url(#irisBlurRight-${setId})"/>
                <ellipse cx="105" cy="58" rx="25" ry="25" fill="url(#irisGradient2Right-${setId})" filter="url(#irisBlurRight-${setId})"/>
                <ellipse cx="100" cy="65" rx="22" ry="22" fill="url(#irisGradient3Right-${setId})" filter="url(#irisBlur2Right-${setId})"/>
                <!-- Additional texture layers -->
                <ellipse cx="92" cy="62" rx="15" ry="15" fill="url(#irisGradient1Right-${setId})" filter="url(#irisBlur2Right-${setId})" opacity="0.4"/>
                <ellipse cx="108" cy="55" rx="18" ry="18" fill="url(#irisGradient2Right-${setId})" filter="url(#irisBlurRight-${setId})" opacity="0.5"/>
            </g>

            <!-- Black pupil -->
            <g class="iris">
                <ellipse cx="100" cy="60" rx="15" ry="15" fill="#000"/>
                <!-- Lens flare inside pupil -->
                <ellipse cx="95" cy="55" rx="3" ry="4" fill="rgba(255,255,255,0.9)"/>
                <ellipse cx="92" cy="52" rx="1.5" ry="1.5" fill="rgba(255,255,255,0.7)"/>
            </g>
        </svg>
`;
            return container;
        }

        // Eye sets state management
        const eyeSets = [];
        let activeSetIndex = -1;
        const maxSets = 10;

        // Spider mode state management
        let isSpiderModeActive = false;
        const spiderEyes = [];
        const spiderEyeCount = 200;

        // Hidden eye indices (corner eyes that are hidden via CSS - don't process these)
        const hiddenEyeIndices = new Set([
            // Row 1
            0, 1, 2, 3, 11, 12, 13,
            // Row 2
            14, 15, 26, 27,
            // Row 3
            28, 29, 41,
            // Row 4
            42, 55,
            // Row 11
            140,
            // Row 12
            154, 166, 167,
            // Row 13
            168, 169, 180, 181,
            // Row 14
            182, 183, 184, 193, 194, 195,
            // Row 15
            196, 197, 198, 199
        ]);

        // Eye tracking state
        let isTrackingMode = false;
        let isAutoMode = false;
        let focalPoint = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let focalPointTarget = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let focalPointAnimationId = null;
        let focalPointTimeoutId = null;
        let autoModeTimeoutId = null;
        let manualControlActive = false;
        let manualControlTimeoutId = null;

        // Arrow key hold state for quadratic acceleration
        let heldArrowKeys = {}; // Tracks held arrow keys: { ArrowUp: timestamp, ... }
        let arrowKeyAnimationId = null; // requestAnimationFrame ID for continuous movement

        // localStorage persistence state
        const localStorageKey = 'eyesAppState';
        let saveStateDebounceTimer = null;

        // Gamepad state
        let gamepadAnimationId = null;
        let connectedGamepad = null;

        // Default values for new eye sets
        const defaultState = {
            scale: 1,
            gap: 20,
            posX: 0,
            posY: 0,
            blinkTimeoutId: null,
            moveTimeoutId: null,
            dripTimeoutId: null,
            everShown: false
        };

        // Constants
        const minScale = 0.05;
        const maxScale = 10;
        const scaleStep = 0.05;
        const minGap = -50;
        const maxGap = 200;
        const gapStep = 3;
        const posStep = 40;

        // Arrow key acceleration constants
        const arrowKeyBaseSpeed = 2; // Minimum speed for quick taps (pixels/frame)
        const arrowKeyAcceleration = 150; // Acceleration multiplier for quadratic curve
        const arrowKeyMaxSpeed = 100; // Maximum speed cap (pixels/frame)

        // localStorage constants
        const saveStateDebounceDelay = 500; // Milliseconds to wait before saving state

        // Focal point tracking constants
        const focalPointManualMoveStep = 1000; // Pixels per arrow key press
        const focalPointMoveDelayMin = 3000; // Min milliseconds between random moves
        const focalPointMoveDelayMax = 7000; // Max milliseconds between random moves
        const focalPointSmoothingFactor = 0.65; // Lerp factor for smooth movement
        const manualControlTimeout = 5000; // Milliseconds before resuming auto movement

        // Gamepad constants
        const gamepadDeadzone = 0.15; // Ignore small joystick movements below this threshold
        const gamepadSensitivity = 100; // Multiplier for joystick movement speed

        // Auto mode constants
        const autoModeToggleDelayMin = 4000; // Min milliseconds between mode switches
        const autoModeToggleDelayMax = 12000; // Max milliseconds between mode switches

        // Spider eye animation constants
        const spiderEyeBlinkDelayMin = 4000; // Min milliseconds between blinks
        const spiderEyeBlinkDelayMax = 20000; // Max milliseconds between blinks
        const spiderEyeMoveDelayMin = 1000; // Min milliseconds between iris movements
        const spiderEyeMoveDelayMax = 5000; // Max milliseconds between iris movements
        const spiderEyePulseDurationMin = 3; // Min seconds for pulse animation
        const spiderEyePulseDurationMax = 8; // Max seconds for pulse animation
        const spiderEyeIrisMaxMovement = 12; // Maximum pixels iris can move (random mode)
        const spiderEyeTrackingMaxDistance = 25; // Maximum distance iris moves when tracking
        const spiderEyeTrackingDistanceDivisor = 30; // Divisor for tracking distance calculation

        // Drip animation constants
        const dripPoolSize = 30; // Number of reusable drip elements
        const maxSimultaneousDrips = 15; // Maximum drips active at once
        const dripDelayMinSpider = 5000; // Min milliseconds between drips (spider mode)
        const dripDelayMaxSpider = 12000; // Max milliseconds between drips (spider mode)
        const dripDelayMinNormal = 2000; // Min milliseconds between drips (normal mode)
        const dripDelayMaxNormal = 6000; // Max milliseconds between drips (normal mode)
        const dripDurationMin = 1500; // Min milliseconds for drip fall animation
        const dripDurationMax = 2500; // Max milliseconds for drip fall animation
        const dripColors = ['#7a9b3d', '#9b9b3d', '#8b7a3d', '#9b5a5a', '#7a8b3d']; // Sickly liquid colors

        // Drip object pool management
        const dripPool = [];
        let activeDripCount = 0;

        function initializeDripPool() {
            const container = document.getElementById('drips-container');
            for (let i = 0; i < dripPoolSize; i++) {
                const drip = document.createElement('div');
                drip.className = 'drip';
                container.appendChild(drip);
                dripPool.push({
                    element: drip,
                    inUse: false
                });
            }
        }

        function getAvailableDrip() {
            if (activeDripCount >= maxSimultaneousDrips) return null;

            for (let i = 0; i < dripPool.length; i++) {
                if (!dripPool[i].inUse) {
                    dripPool[i].inUse = true;
                    activeDripCount++;
                    return dripPool[i];
                }
            }
            return null;
        }

        function releaseDrip(dripData) {
            if (!dripData) return;
            dripData.inUse = false;
            dripData.element.classList.remove('active');
            dripData.element.style.cssText = '';
            activeDripCount--;
        }

        function spawnDrip(x, y) {
            const dripData = getAvailableDrip();
            if (!dripData) return; // Pool exhausted or max limit reached

            const drip = dripData.element;

            // Random drip properties
            const color = dripColors[Math.floor(Math.random() * dripColors.length)];
            const width = Math.random() * 6 + 4; // 4-10px
            const height = Math.random() * 10 + 8; // 8-18px
            const duration = Math.random() * (dripDurationMax - dripDurationMin) + dripDurationMin;
            const fallDistance = Math.random() * 150 + 150; // 150-300px
            const driftX = (Math.random() - 0.5) * 30; // -15 to 15px horizontal drift

            // Set CSS custom properties and styles
            drip.style.cssText = `
                --drip-color: ${color};
                --drip-duration: ${duration}ms;
                --start-x: 0px;
                --start-y: 0px;
                --fall-distance: ${fallDistance}px;
                --drift-x: ${driftX}px;
                width: ${width}px;
                height: ${height}px;
                left: ${x}px;
                top: ${y}px;
            `;

            // Start animation
            drip.classList.add('active');

            // Release drip after animation completes
            setTimeout(() => {
                releaseDrip(dripData);
            }, duration);
        }

        // Generate random spawn position
        function getRandomSpawnPosition() {
            const randomX = (Math.random() - 0.5) * 800; // -400 to 400
            const randomY = (Math.random() - 0.5) * 400; // -200 to 200
            return { posX: randomX, posY: randomY };
        }

        // Gamepad functions
        function pollGamepad() {
            if (!isTrackingMode) {
                if (gamepadAnimationId) {
                    cancelAnimationFrame(gamepadAnimationId);
                    gamepadAnimationId = null;
                }
                return;
            }

            const gamepads = navigator.getGamepads();
            let activeGamepad = null;

            // Find first connected gamepad
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    activeGamepad = gamepads[i];
                    break;
                }
            }

            if (activeGamepad) {
                // Read left stick axes (axes[0] = X, axes[1] = Y)
                const axisX = activeGamepad.axes[0];
                const axisY = activeGamepad.axes[1];

                // Apply deadzone
                const deadzonedX = Math.abs(axisX) > gamepadDeadzone ? axisX : 0;
                const deadzonedY = Math.abs(axisY) > gamepadDeadzone ? axisY : 0;

                // If joystick is moved, update focal point
                if (deadzonedX !== 0 || deadzonedY !== 0) {
                    const dx = deadzonedX * gamepadSensitivity;
                    const dy = deadzonedY * gamepadSensitivity;
                    moveFocalPointManually(dx, dy);
                }
            }

            // Continue polling
            gamepadAnimationId = requestAnimationFrame(pollGamepad);
        }

        function startGamepadPolling() {
            if (!gamepadAnimationId && isTrackingMode) {
                gamepadAnimationId = requestAnimationFrame(pollGamepad);
            }
        }

        function stopGamepadPolling() {
            if (gamepadAnimationId) {
                cancelAnimationFrame(gamepadAnimationId);
                gamepadAnimationId = null;
            }
        }

        // Focal point tracking functions
        function moveFocalPoint() {
            if (!isSpiderModeActive || !isTrackingMode || manualControlActive) return;

            // Generate random target position
            focalPointTarget = {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight
            };

            // Schedule next move
            const nextMoveDelay = Math.random() * (focalPointMoveDelayMax - focalPointMoveDelayMin) + focalPointMoveDelayMin;
            focalPointTimeoutId = setTimeout(moveFocalPoint, nextMoveDelay);
        }

        function startManualControl() {
            if (!isTrackingMode) return;

            manualControlActive = true;

            // Stop random focal point movement
            if (focalPointTimeoutId) {
                clearTimeout(focalPointTimeoutId);
                focalPointTimeoutId = null;
            }

            // Reset the 5-second timer
            if (manualControlTimeoutId) {
                clearTimeout(manualControlTimeoutId);
            }

            manualControlTimeoutId = setTimeout(() => {
                manualControlActive = false;
                // Resume random movement
                moveFocalPoint();
            }, manualControlTimeout);
        }

        function moveFocalPointManually(dx, dy) {
            if (!isTrackingMode) return;

            startManualControl();

            // Move the focal point target
            focalPointTarget.x = Math.max(0, Math.min(window.innerWidth, focalPointTarget.x + dx));
            focalPointTarget.y = Math.max(0, Math.min(window.innerHeight, focalPointTarget.y + dy));
        }

        function updateFocalPointPosition() {
            if (!isTrackingMode) return;

            // Smoothly interpolate toward target
            focalPoint.x += (focalPointTarget.x - focalPoint.x) * focalPointSmoothingFactor;
            focalPoint.y += (focalPointTarget.y - focalPoint.y) * focalPointSmoothingFactor;
        }

        function updateEyeTracking() {
            if (!isSpiderModeActive || !isTrackingMode) return;

            // Update focal point position
            updateFocalPointPosition();

            // Update all visible spider eyes (hidden corner eyes are excluded from array)
            spiderEyes.forEach((eyeData, index) => {
                if (!eyeData || !eyeData.element) return;

                // Get eye position
                const rect = eyeData.element.getBoundingClientRect();
                const eyeCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                // Calculate vector to focal point
                const dx = focalPoint.x - eyeCenter.x;
                const dy = focalPoint.y - eyeCenter.y;

                // Calculate angle and distance
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const distance = Math.min(spiderEyeTrackingMaxDistance, dist / spiderEyeTrackingDistanceDivisor);

                // Calculate iris offset
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                // Apply to iris elements
                const irises = eyeData.element.querySelectorAll('.iris');
                irises.forEach(iris => {
                    iris.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                });
            });

            // Continue loop
            focalPointAnimationId = requestAnimationFrame(updateEyeTracking);
        }

        function startFocalPointTracking() {
            if (isTrackingMode) return;

            isTrackingMode = true;

            // Initialize focal point at center
            focalPoint = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            focalPointTarget = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

            // Start movement
            moveFocalPoint();

            // Start tracking loop
            focalPointAnimationId = requestAnimationFrame(updateEyeTracking);

            // Start gamepad polling
            startGamepadPolling();
        }

        function stopFocalPointTracking() {
            if (!isTrackingMode) return;

            isTrackingMode = false;

            // Stop movement timer
            if (focalPointTimeoutId) {
                clearTimeout(focalPointTimeoutId);
                focalPointTimeoutId = null;
            }

            // Stop manual control timer
            if (manualControlTimeoutId) {
                clearTimeout(manualControlTimeoutId);
                manualControlTimeoutId = null;
            }
            manualControlActive = false;

            // Stop tracking loop
            if (focalPointAnimationId) {
                cancelAnimationFrame(focalPointAnimationId);
                focalPointAnimationId = null;
            }

            // Stop gamepad polling
            stopGamepadPolling();
        }

        function toggleTrackingMode() {
            if (!isSpiderModeActive) return;

            // If auto mode is active, turn it off first
            if (isAutoMode) {
                isAutoMode = false;
                if (autoModeTimeoutId) {
                    clearTimeout(autoModeTimeoutId);
                    autoModeTimeoutId = null;
                }
            }

            // Only turn on tracking mode, don't toggle off
            if (!isTrackingMode) {
                // Switch to tracking mode
                // Stop all random movement
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && eyeData.moveTimeoutId) {
                        clearTimeout(eyeData.moveTimeoutId);
                        eyeData.moveTimeoutId = null;
                    }
                }

                startFocalPointTracking();
            }
        }

        function autoToggleTracking() {
            if (!isSpiderModeActive || !isAutoMode) return;

            // Toggle tracking mode
            if (isTrackingMode) {
                // Switch to normal mode
                stopFocalPointTracking();

                // Restart random movement for all eyes
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && !eyeData.moveTimeoutId) {
                        const initialDelay = Math.random() * 1500 + 500;
                        eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(i), initialDelay);
                    }
                }
            } else {
                // Switch to tracking mode
                // Stop all random movement
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && eyeData.moveTimeoutId) {
                        clearTimeout(eyeData.moveTimeoutId);
                        eyeData.moveTimeoutId = null;
                    }
                }

                startFocalPointTracking();
            }

            // Schedule next toggle
            const nextToggleDelay = Math.random() * (autoModeToggleDelayMax - autoModeToggleDelayMin) + autoModeToggleDelayMin;
            autoModeTimeoutId = setTimeout(autoToggleTracking, nextToggleDelay);
        }

        function toggleAutoMode() {
            if (!isSpiderModeActive) return;

            if (isAutoMode) {
                // Turn off auto mode
                isAutoMode = false;

                // Clear auto mode timer
                if (autoModeTimeoutId) {
                    clearTimeout(autoModeTimeoutId);
                    autoModeTimeoutId = null;
                }

                // Leave current tracking state as is
            } else {
                // Turn on auto mode
                isAutoMode = true;

                // Start auto toggling
                autoToggleTracking();
            }
        }

        // Drip spawning functions
        function dripSpiderEye(eyeId) {
            if (!isSpiderModeActive) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Get eye position on screen
            const rect = eyeData.element.getBoundingClientRect();

            // Spawn drip at random position along bottom of eye
            const randomXOffset = (Math.random() - 0.5) * rect.width * 0.6; // Random position along bottom
            const spawnX = rect.left + rect.width / 2 + randomXOffset;
            const spawnY = rect.bottom - 5; // Just below eye

            spawnDrip(spawnX, spawnY);

            // Schedule next drip
            const nextDripDelay = Math.random() * (dripDelayMaxSpider - dripDelayMinSpider) + dripDelayMinSpider;
            eyeData.dripTimeoutId = setTimeout(() => dripSpiderEye(eyeId), nextDripDelay);
        }

        function dripEyeSet(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const eyes = eyeSet.element.querySelectorAll('.eye');

            // Drip from both eyes
            eyes.forEach(eye => {
                const rect = eye.getBoundingClientRect();

                // Spawn drip at random position along bottom of eye
                const randomXOffset = (Math.random() - 0.5) * rect.width * 0.5;
                const spawnX = rect.left + rect.width / 2 + randomXOffset;
                const spawnY = rect.bottom - 10;

                spawnDrip(spawnX, spawnY);
            });

            // Schedule next drip
            const nextDripDelay = Math.random() * (dripDelayMaxNormal - dripDelayMinNormal) + dripDelayMinNormal;
            eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(setIndex), nextDripDelay);
        }

        // Spider mode functions
        function blinkSpiderEye(eyeId) {
            if (!isSpiderModeActive) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Store the current pulse animation
            const currentAnimation = eyeData.element.style.animation;

            // Apply blink animation (overrides pulse temporarily)
            eyeData.element.style.animation = 'eyeBlink 0.4s ease-in-out';

            // Restore pulse animation after blink completes
            setTimeout(() => {
                eyeData.element.style.animation = currentAnimation;
            }, 400);

            // Schedule next blink
            const nextBlinkDelay = Math.random() * (spiderEyeBlinkDelayMax - spiderEyeBlinkDelayMin) + spiderEyeBlinkDelayMin;
            eyeData.blinkTimeoutId = setTimeout(() => blinkSpiderEye(eyeId), nextBlinkDelay);
        }

        function moveSpiderEyeIris(eyeId) {
            if (!isSpiderModeActive || isTrackingMode) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            const irises = eyeData.element.querySelectorAll('.iris');

            // Generate random position within eye bounds
            const randomX = (Math.random() - 0.5) * 2 * spiderEyeIrisMaxMovement;
            const randomY = (Math.random() - 0.5) * 2 * spiderEyeIrisMaxMovement;

            // Apply movement to all iris groups
            irises.forEach(iris => {
                iris.style.transform = `translate(${randomX}px, ${randomY}px)`;
            });

            // Schedule next movement (only if not in tracking mode)
            if (!isTrackingMode) {
                const nextMoveDelay = Math.random() * (spiderEyeMoveDelayMax - spiderEyeMoveDelayMin) + spiderEyeMoveDelayMin;
                eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(eyeId), nextMoveDelay);
            }
        }

        function startSpiderEyeAnimations(eyeId) {
            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Apply pulsing animation with random duration
            const pulseDuration = Math.random() * (spiderEyePulseDurationMax - spiderEyePulseDurationMin) + spiderEyePulseDurationMin;
            eyeData.element.style.animation = `eyePulse ${pulseDuration}s infinite ease-in-out`;

            // Apply color animations with random delay
            const randomDelay = Math.random() * 60;
            const animationStyle = `colorShift 60s infinite linear ${randomDelay}s`;

            // Apply animations to iris-main elements only
            const irisMainElements = eyeData.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = animationStyle;
            });

            // Start blinking with initial random delay (1-3 seconds)
            const initialBlinkDelay = Math.random() * 2000 + 1000;
            eyeData.blinkTimeoutId = setTimeout(() => blinkSpiderEye(eyeId), initialBlinkDelay);

            // Start iris movement with initial random delay (0.5-2 seconds) - only if not in tracking mode
            if (!isTrackingMode) {
                const initialMoveDelay = Math.random() * 1500 + 500;
                eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(eyeId), initialMoveDelay);
            }

            // Start dripping with initial random delay (2-5 seconds)
            const initialDripDelay = Math.random() * 3000 + 2000;
            eyeData.dripTimeoutId = setTimeout(() => dripSpiderEye(eyeId), initialDripDelay);
        }

        function stopSpiderEyeAnimations(eyeId) {
            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Clear timeout timers
            if (eyeData.blinkTimeoutId) {
                clearTimeout(eyeData.blinkTimeoutId);
                eyeData.blinkTimeoutId = null;
            }
            if (eyeData.moveTimeoutId) {
                clearTimeout(eyeData.moveTimeoutId);
                eyeData.moveTimeoutId = null;
            }
            if (eyeData.dripTimeoutId) {
                clearTimeout(eyeData.dripTimeoutId);
                eyeData.dripTimeoutId = null;
            }

            // Remove pulse animation from eye element
            eyeData.element.style.animation = '';

            // Remove color animations
            const irisMainElements = eyeData.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = '';
            });
        }

        function initializeSpiderMode() {
            const spiderStage = document.getElementById('spider-stage');

            // Create all spider eyes if not already created
            if (spiderEyes.length === 0) {
                for (let i = 0; i < spiderEyeCount; i++) {
                    const eyeElement = createSpiderEye(i);
                    spiderStage.appendChild(eyeElement);

                    // Only track visible eyes (skip hidden corner eyes)
                    if (!hiddenEyeIndices.has(i)) {
                        spiderEyes.push({
                            element: eyeElement,
                            blinkTimeoutId: null,
                            moveTimeoutId: null,
                            dripTimeoutId: null
                        });
                    }
                }
            }
        }

        function toggleSpiderMode() {
            const eyesStage = document.getElementById('eyes-stage');
            const spiderStage = document.getElementById('spider-stage');

            if (!isSpiderModeActive) {
                // Entering spider mode
                isSpiderModeActive = true;

                // Hide normal eyes
                eyesStage.classList.add('spider-mode-active');

                // Stop all normal eye animations
                for (let i = 0; i < eyeSets.length; i++) {
                    if (eyeSets[i] && eyeSets[i].visible) {
                        stopEyeSetAnimations(i);
                    }
                }

                // Initialize spider eyes if first time
                initializeSpiderMode();

                // Show spider grid
                spiderStage.classList.add('active');

                // Start all spider eye animations (only for visible eyes)
                for (let i = 0; i < spiderEyes.length; i++) {
                    startSpiderEyeAnimations(i);
                }

                // Start auto creepy mode by default
                toggleAutoMode();
            } else {
                // Exiting spider mode
                isSpiderModeActive = false;

                // Stop auto mode if active
                if (isAutoMode) {
                    isAutoMode = false;
                    if (autoModeTimeoutId) {
                        clearTimeout(autoModeTimeoutId);
                        autoModeTimeoutId = null;
                    }
                }

                // Stop tracking if active
                if (isTrackingMode) {
                    stopFocalPointTracking();
                }

                // Stop all spider eye animations (only for visible eyes)
                for (let i = 0; i < spiderEyes.length; i++) {
                    stopSpiderEyeAnimations(i);
                }

                // Hide spider grid
                spiderStage.classList.remove('active');

                // Show normal eyes
                eyesStage.classList.remove('spider-mode-active');

                // Check if any eye sets are visible
                let hasVisibleSets = false;
                for (let i = 0; i < eyeSets.length; i++) {
                    if (eyeSets[i] && eyeSets[i].visible) {
                        hasVisibleSets = true;
                        startEyeSetAnimations(i);
                    }
                }

                // If no eye sets are visible, show the first set
                if (!hasVisibleSets) {
                    toggleEyeSet(0);
                }
            }
        }

        // Per-set blinking function
        function blinkEyeSet(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const eyes = eyeSet.element.querySelectorAll('.eye');

            // Add blink class
            eyes.forEach(eye => eye.classList.add('blinking'));

            // Remove blink class after 100ms (blink duration)
            setTimeout(() => {
                eyes.forEach(eye => eye.classList.remove('blinking'));
            }, 100);

            // Schedule next blink randomly between 4-20 seconds
            const nextBlinkDelay = Math.random() * 16000 + 4000; // 4000ms to 20000ms
            eyeSet.blinkTimeoutId = setTimeout(() => blinkEyeSet(setIndex), nextBlinkDelay);
        }

        // Per-set iris movement function
        function moveEyeSetIris(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const irises = eyeSet.element.querySelectorAll('.iris');

            // Generate random position within eye bounds
            const maxX = 50; // Maximum horizontal movement
            const maxY = 10; // Maximum vertical movement
            const randomX = (Math.random() - 0.5) * 2 * maxX; // -50 to 50
            const randomY = (Math.random() - 0.5) * 2 * maxY; // -10 to 10

            // Apply movement to all iris groups (iris, pupil, lens flare)
            irises.forEach(iris => {
                iris.style.transform = `translate(${randomX}px, ${randomY}px)`;
            });

            // Schedule next movement randomly between 1-5 seconds
            const nextMoveDelay = Math.random() * 5000 + 1000; // 1000ms to 5000ms
            eyeSet.moveTimeoutId = setTimeout(() => moveEyeSetIris(setIndex), nextMoveDelay);
        }

        // Start all animations for an eye set
        function startEyeSetAnimations(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Apply color animations with random delay to desync from other sets
            const randomDelay = Math.random() * 60; // 0-60 seconds
            const animationStyle = `colorShift 60s infinite linear ${randomDelay}s`;
            const gradientAnimations = [
                `colorShift1 60s infinite linear ${randomDelay}s`,
                `colorShift2 60s infinite linear ${randomDelay}s`,
                `colorShift3 60s infinite linear ${randomDelay}s`,
                `colorShift4 60s infinite linear ${randomDelay}s`
            ];

            // Apply animations to iris-main elements
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = animationStyle;
            });

            // Apply animations to gradient stops
            const gradientStops = eyeSet.element.querySelectorAll('.iris-gradient-stop-1, .iris-gradient-stop-2, .iris-gradient-stop-3, .iris-gradient-stop-4');
            gradientStops.forEach(stop => {
                if (stop.classList.contains('iris-gradient-stop-1')) {
                    stop.style.animation = gradientAnimations[0];
                } else if (stop.classList.contains('iris-gradient-stop-2')) {
                    stop.style.animation = gradientAnimations[1];
                } else if (stop.classList.contains('iris-gradient-stop-3')) {
                    stop.style.animation = gradientAnimations[2];
                } else if (stop.classList.contains('iris-gradient-stop-4')) {
                    stop.style.animation = gradientAnimations[3];
                }
            });

            // Start blinking with initial random delay (1-3 seconds)
            const initialBlinkDelay = Math.random() * 2000 + 1000;
            eyeSet.blinkTimeoutId = setTimeout(() => blinkEyeSet(setIndex), initialBlinkDelay);

            // Start iris movement with initial random delay (0.5-2 seconds)
            const initialMoveDelay = Math.random() * 1500 + 500;
            eyeSet.moveTimeoutId = setTimeout(() => moveEyeSetIris(setIndex), initialMoveDelay);

            // Start dripping with initial random delay (1-3 seconds)
            const initialDripDelay = Math.random() * 2000 + 1000;
            eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(setIndex), initialDripDelay);
        }

        // Stop all animations for an eye set
        function stopEyeSetAnimations(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Clear timeout timers
            if (eyeSet.blinkTimeoutId) {
                clearTimeout(eyeSet.blinkTimeoutId);
                eyeSet.blinkTimeoutId = null;
            }
            if (eyeSet.moveTimeoutId) {
                clearTimeout(eyeSet.moveTimeoutId);
                eyeSet.moveTimeoutId = null;
            }
            if (eyeSet.dripTimeoutId) {
                clearTimeout(eyeSet.dripTimeoutId);
                eyeSet.dripTimeoutId = null;
            }

            // Remove color animations
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = '';
            });

            const gradientStops = eyeSet.element.querySelectorAll('.iris-gradient-stop-1, .iris-gradient-stop-2, .iris-gradient-stop-3, .iris-gradient-stop-4');
            gradientStops.forEach(stop => {
                stop.style.animation = '';
            });
        }

        // Create or get an eye set
        function getOrCreateEyeSet(setIndex) {
            if (eyeSets[setIndex]) {
                return eyeSets[setIndex];
            }

            // Create new eye set
            const container = createEyePair(setIndex);
            const state = { ...defaultState };

            eyeSets[setIndex] = {
                element: container,
                ...state,
                visible: false
            };

            document.getElementById('eyes-stage').appendChild(container);
            return eyeSets[setIndex];
        }

        // Update eye set transform
        function updateEyeSetTransform(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { scale, posX, posY, gap } = eyeSet;
            eyeSet.element.style.transform = `translate(calc(-50% + ${posX}px), calc(-50% + ${posY}px)) scale(${scale})`;
            eyeSet.element.style.gap = `${gap}vw`;
        }

        // Save state to localStorage
        function saveStateToLocalStorage() {
            try {
                const state = {
                    eyeSets: [],
                    activeSetIndex: activeSetIndex
                };

                // Save only persistable properties for each eye set
                for (let i = 0; i < maxSets; i++) {
                    const eyeSet = eyeSets[i];
                    if (eyeSet) {
                        state.eyeSets[i] = {
                            scale: eyeSet.scale,
                            gap: eyeSet.gap,
                            posX: eyeSet.posX,
                            posY: eyeSet.posY,
                            visible: eyeSet.visible,
                            everShown: eyeSet.everShown
                        };
                    } else {
                        state.eyeSets[i] = null;
                    }
                }

                localStorage.setItem(localStorageKey, JSON.stringify(state));
            } catch (error) {
                console.error('Failed to save state to localStorage:', error);
            }
        }

        // Debounced save to avoid excessive localStorage writes
        function debouncedSaveState() {
            if (saveStateDebounceTimer) {
                clearTimeout(saveStateDebounceTimer);
            }
            saveStateDebounceTimer = setTimeout(saveStateToLocalStorage, saveStateDebounceDelay);
        }

        // Load state from localStorage
        function loadStateFromLocalStorage() {
            try {
                const savedState = localStorage.getItem(localStorageKey);
                if (!savedState) return null;

                return JSON.parse(savedState);
            } catch (error) {
                console.error('Failed to load state from localStorage:', error);
                return null;
            }
        }

        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();

            // Spacebar to toggle instructions
            if (key === ' ') {
                event.preventDefault();
                const instructions = document.getElementById('instructions');
                instructions.classList.toggle('visible');
                return;
            }

            // Z key to toggle Spider Mode
            if (key === 'z') {
                event.preventDefault();
                toggleSpiderMode();
                return;
            }

            // X key to toggle eye tracking (spider mode only)
            if (key === 'x') {
                event.preventDefault();
                toggleTrackingMode();
                return;
            }

            // C key to toggle auto mode (spider mode only)
            if (key === 'c') {
                event.preventDefault();
                toggleAutoMode();
                return;
            }

            // Arrow keys - control focal point if in tracking mode, otherwise control eye position
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();

                if (isTrackingMode) {
                    // Spider mode tracking - use fixed step movement
                    if (event.key === 'ArrowUp') {
                        moveFocalPointManually(0, -focalPointManualMoveStep);
                    } else if (event.key === 'ArrowDown') {
                        moveFocalPointManually(0, focalPointManualMoveStep);
                    } else if (event.key === 'ArrowLeft') {
                        moveFocalPointManually(-focalPointManualMoveStep, 0);
                    } else if (event.key === 'ArrowRight') {
                        moveFocalPointManually(focalPointManualMoveStep, 0);
                    }
                } else if (activeSetIndex !== -1) {
                    // Normal mode - use hold-duration quadratic acceleration
                    // Record key press timestamp (only on first press, ignore repeat events)
                    if (!heldArrowKeys[event.key]) {
                        heldArrowKeys[event.key] = Date.now();

                        // Start animation loop if not already running
                        if (!arrowKeyAnimationId) {
                            arrowKeyAnimationId = requestAnimationFrame(updateArrowKeyMovement);
                        }
                    }
                }
                return;
            }

            // Number keys 1-0 for eye set toggle (maps to sets 0-9)
            if (key >= '1' && key <= '9') {
                event.preventDefault();
                const setIndex = parseInt(key) - 1;
                toggleEyeSet(setIndex);
                return;
            } else if (key === '0') {
                event.preventDefault();
                toggleEyeSet(9); // 0 key maps to set 9
                return;
            }

            // Control keys only work if there's an active set
            if (activeSetIndex === -1) return;
            const eyeSet = eyeSets[activeSetIndex];

            // Q/W for scale (up/down)
            if (key === 'q') {
                event.preventDefault();
                eyeSet.scale = Math.min(eyeSet.scale + scaleStep, maxScale);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            } else if (key === 'w') {
                event.preventDefault();
                eyeSet.scale = Math.max(eyeSet.scale - scaleStep, minScale);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            }
            // E/R for gap (wider/closer)
            else if (key === 'e') {
                event.preventDefault();
                eyeSet.gap = Math.min(eyeSet.gap + gapStep, maxGap);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            } else if (key === 'r') {
                event.preventDefault();
                eyeSet.gap = Math.max(eyeSet.gap - gapStep, minGap);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            }
        });

        // Keyup listener to clear arrow key hold state
        document.addEventListener('keyup', (event) => {
            // Clear held arrow key when released
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                delete heldArrowKeys[event.key];

                // Stop animation loop if no keys are held
                if (Object.keys(heldArrowKeys).length === 0 && arrowKeyAnimationId) {
                    cancelAnimationFrame(arrowKeyAnimationId);
                    arrowKeyAnimationId = null;
                }
            }
        });

        // Animation loop for continuous arrow key movement with quadratic acceleration
        function updateArrowKeyMovement() {
            // Only proceed if there are held keys and an active eye set
            if (Object.keys(heldArrowKeys).length === 0 || activeSetIndex === -1) {
                arrowKeyAnimationId = null;
                return;
            }

            const now = Date.now();
            const eyeSet = eyeSets[activeSetIndex];

            // Process each held arrow key
            for (const key in heldArrowKeys) {
                const pressDuration = (now - heldArrowKeys[key]) / 1000; // Convert to seconds

                // Calculate speed using quadratic acceleration: speed = baseSpeed + acceleration * t^2
                const speed = Math.min(
                    arrowKeyBaseSpeed + arrowKeyAcceleration * pressDuration * pressDuration,
                    arrowKeyMaxSpeed
                );

                // Update position based on key direction
                if (key === 'ArrowUp') {
                    eyeSet.posY -= speed;
                } else if (key === 'ArrowDown') {
                    eyeSet.posY += speed;
                } else if (key === 'ArrowLeft') {
                    eyeSet.posX -= speed;
                } else if (key === 'ArrowRight') {
                    eyeSet.posX += speed;
                }
            }

            // Apply the position update
            updateEyeSetTransform(activeSetIndex);
            debouncedSaveState();

            // Continue animation loop
            arrowKeyAnimationId = requestAnimationFrame(updateArrowKeyMovement);
        }

        // Toggle eye set visibility and active state
        function toggleEyeSet(setIndex) {
            if (setIndex < 0 || setIndex >= maxSets) return;

            const eyeSet = getOrCreateEyeSet(setIndex);

            // If this set is active and visible, hide it
            if (activeSetIndex === setIndex && eyeSet.visible) {
                eyeSet.visible = false;
                eyeSet.element.classList.add('hidden');
                stopEyeSetAnimations(setIndex);
                debouncedSaveState();
                return;
            }

            // If this set exists but is not active, make it active
            if (!eyeSet.visible) {
                // First time showing this eye set - spawn at random location
                if (!eyeSet.everShown) {
                    const randomPos = getRandomSpawnPosition();
                    eyeSet.posX = randomPos.posX;
                    eyeSet.posY = randomPos.posY;
                    eyeSet.everShown = true;
                }

                eyeSet.visible = true;
                eyeSet.element.classList.remove('hidden');
                // Apply initial transform to center the eyes
                updateEyeSetTransform(setIndex);
                // Stop existing animations and restart with fresh timing
                stopEyeSetAnimations(setIndex);
                startEyeSetAnimations(setIndex);
            }

            activeSetIndex = setIndex;
            debouncedSaveState();
        }

        // Gamepad event listeners
        window.addEventListener('gamepadconnected', (event) => {
            connectedGamepad = event.gamepad;
            console.log(`Gamepad connected: ${event.gamepad.id}`);
            console.log('Use left stick to control focal point in tracking mode');

            // Start polling if in tracking mode
            if (isTrackingMode) {
                startGamepadPolling();
            }
        });

        window.addEventListener('gamepaddisconnected', (event) => {
            console.log(`Gamepad disconnected: ${event.gamepad.id}`);
            connectedGamepad = null;
            stopGamepadPolling();
        });

        // Initialize first eye set on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Console message
            console.log('Press Space bar for help');

            // Initialize drip pool
            initializeDripPool();

            // Show help message on page load
            const helpMessage = document.getElementById('help-message');
            setTimeout(() => {
                helpMessage.classList.add('visible');
            }, 100); // Small delay to ensure transition works

            // Fade out after 5 seconds
            setTimeout(() => {
                helpMessage.classList.remove('visible');
            }, 5100);

            // Try to restore saved state from localStorage
            const savedState = loadStateFromLocalStorage();
            if (savedState && savedState.eyeSets) {
                // Restore eye sets from saved state
                for (let i = 0; i < maxSets; i++) {
                    const savedSet = savedState.eyeSets[i];
                    if (savedSet) {
                        // Create or get the eye set
                        const eyeSet = getOrCreateEyeSet(i);

                        // Restore saved properties
                        eyeSet.scale = savedSet.scale;
                        eyeSet.gap = savedSet.gap;
                        eyeSet.posX = savedSet.posX;
                        eyeSet.posY = savedSet.posY;
                        eyeSet.visible = savedSet.visible;
                        eyeSet.everShown = savedSet.everShown;

                        // If this set was visible, show it
                        if (savedSet.visible) {
                            eyeSet.element.classList.remove('hidden');
                            updateEyeSetTransform(i);
                            startEyeSetAnimations(i);
                        }
                    }
                }

                // Restore active set index
                activeSetIndex = savedState.activeSetIndex;

                console.log('Restored eye sets from localStorage');
            } else {
                // No saved state - start in spider mode by default
                toggleSpiderMode();
            }
        });
    </script>
</body>
</html>