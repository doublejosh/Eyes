<!DOCTYPE html>
<!-- GitHub: https://github.com/doublejosh/Eyes -->
<!-- Press Space bar for help -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eyes</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .eyes-container {
            display: flex;
            gap: 20vw;
            align-items: center;
            transform: scale(1) translate(0, 0);
            transition: transform 0.3s ease-out, gap 0.3s ease-out;
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
        }

        .eyes-container.hidden {
            display: none;
        }

        .eye {
            width: 200px;
            height: 120px;
            cursor: pointer;
            transition: transform 0.1s ease-out;
        }

        .eye.blinking {
            transform: scaleY(0.1);
        }

        .iris {
            transition: transform 1.5s ease-out;
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            color: #ccc;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 300px;
            display: none;
        }

        .instructions.visible {
            display: block;
        }

        .instructions h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
        }

        .instructions p {
            margin: 8px 0;
        }

        .instructions kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        .help-message {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 60px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            pointer-events: none;
            z-index: 1000;
        }

        .help-message.visible {
            opacity: 1;
        }

        .spider-grid {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            grid-template-columns: repeat(14, 60px);
            row-gap: -8px;
            column-gap: 8px;
            padding: 20px;
        }

        .spider-grid.active {
            display: grid;
        }

        .spider-eye {
            width: 60px;
            height: 60px;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .spider-eye.blinking {
            transform: scaleY(0.7);
        }

        /* Offset every other row (rows 2, 4, 6, 8, 10, 12, 14) */
        .spider-eye:nth-child(n+15):nth-child(-n+28),
        .spider-eye:nth-child(n+43):nth-child(-n+56),
        .spider-eye:nth-child(n+71):nth-child(-n+84),
        .spider-eye:nth-child(n+99):nth-child(-n+112),
        .spider-eye:nth-child(n+127):nth-child(-n+140),
        .spider-eye:nth-child(n+155):nth-child(-n+168),
        .spider-eye:nth-child(n+183):nth-child(-n+196) {
            margin-left: 30px;
        }

        /* Hide corner eyes to make circular shape for 14x14 grid */
        /* Row 1: hide outer corners */
        .spider-eye:nth-child(1),
        .spider-eye:nth-child(2),
        .spider-eye:nth-child(3),
        .spider-eye:nth-child(4),
        .spider-eye:nth-child(12),
        .spider-eye:nth-child(13),
        .spider-eye:nth-child(14),
        /* Row 2: hide corners */
        .spider-eye:nth-child(15),
        .spider-eye:nth-child(16),
        .spider-eye:nth-child(27),
        .spider-eye:nth-child(28),
        /* Row 3: hide corners */
        .spider-eye:nth-child(29),
        .spider-eye:nth-child(30),
        .spider-eye:nth-child(42),
        /* Row 4: hide corners */
        .spider-eye:nth-child(43),
        .spider-eye:nth-child(56),
        /* Row 11: hide corners */
        .spider-eye:nth-child(141),
        /* Row 12: hide corners */
        .spider-eye:nth-child(155),
        .spider-eye:nth-child(167),
        .spider-eye:nth-child(168),
        /* Row 13: hide corners */
        .spider-eye:nth-child(169),
        .spider-eye:nth-child(170),
        .spider-eye:nth-child(181),
        .spider-eye:nth-child(182),
        /* Row 14: hide corners */
        .spider-eye:nth-child(183),
        .spider-eye:nth-child(184),
        .spider-eye:nth-child(185),
        .spider-eye:nth-child(194),
        .spider-eye:nth-child(195),
        .spider-eye:nth-child(196),
        /* Row 15: hide orphaned eyes */
        .spider-eye:nth-child(197),
        .spider-eye:nth-child(198),
        .spider-eye:nth-child(199),
        .spider-eye:nth-child(200) {
            visibility: hidden;
        }

        #eyes-stage.spider-mode-active {
            display: none;
        }

        @keyframes colorShift1 {
            0% { stop-color: #4CAF50; }      /* Light Green */
            16.67% { stop-color: #D2691E; }  /* Saddle Brown */
            33.33% { stop-color: #6495ED; }  /* Cornflower Blue */
            50% { stop-color: #FFB347; }     /* Light Orange */
            66.67% { stop-color: #F08080; }  /* Light Coral */
            83.33% { stop-color: #FFB6C1; }  /* Light Pink */
            100% { stop-color: #4CAF50; }    /* Back to Light Green */
        }

        @keyframes colorShift2 {
            0% { stop-color: #388E3C; }      /* Medium Green */
            16.67% { stop-color: #A0522D; }  /* Sienna */
            33.33% { stop-color: #4169E1; }  /* Royal Blue */
            50% { stop-color: #FF8C00; }     /* Dark Orange */
            66.67% { stop-color: #DC143C; }  /* Crimson */
            83.33% { stop-color: #FF69B4; }  /* Hot Pink */
            100% { stop-color: #388E3C; }    /* Back to Medium Green */
        }

        @keyframes colorShift3 {
            0% { stop-color: #2E7D32; }      /* Dark Green */
            16.67% { stop-color: #8B4513; }  /* Saddle Brown */
            33.33% { stop-color: #1E90FF; }  /* Dodge Blue */
            50% { stop-color: #FF7F00; }     /* Orange */
            66.67% { stop-color: #B22222; }  /* Fire Brick */
            83.33% { stop-color: #C71585; }  /* Medium Violet Red */
            100% { stop-color: #2E7D32; }    /* Back to Dark Green */
        }

        @keyframes colorShift4 {
            0% { stop-color: #1B5E20; }      /* Very Dark Green */
            16.67% { stop-color: #654321; }  /* Dark Brown */
            33.33% { stop-color: #000080; }  /* Navy */
            50% { stop-color: #CC5500; }     /* Burnt Orange */
            66.67% { stop-color: #800020; }  /* Burgundy */
            83.33% { stop-color: #8B008B; }  /* Dark Magenta */
            100% { stop-color: #1B5E20; }    /* Back to Very Dark Green */
        }

        @keyframes colorShift {
            0% { fill: #8b0000; }      /* Dark Red */
            16.67% { fill: #4a0000; }  /* Darker Red */
            33.33% { fill: #660000; }  /* Blood Red */
            50% { fill: #8b0000; }     /* Dark Red */
            66.67% { fill: #a00000; }  /* Crimson */
            83.33% { fill: #660000; }  /* Blood Red */
            100% { fill: #8b0000; }    /* Back to Dark Red */
        }

        @keyframes eyePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.16); }
        }

        @keyframes eyeBlink {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.85); }
        }

        /* Drip container and animations */
        #drips-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .drip {
            position: absolute;
            background: var(--drip-color, #7a9b3d);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            opacity: 0;
            filter: blur(1px);
            pointer-events: none;
        }

        .drip.active {
            animation: dripFall var(--drip-duration, 2s) ease-in forwards;
        }

        @keyframes dripFall {
            0% {
                opacity: 0.7;
                transform: translate(var(--start-x, 0), var(--start-y, 0)) scaleY(1);
            }
            20% {
                opacity: 0.8;
                transform: translate(calc(var(--start-x, 0) + var(--drift-x, 0px)), calc(var(--start-y, 0) + 30px)) scaleY(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--start-x, 0) + var(--drift-x, 0px)), calc(var(--start-y, 0) + var(--fall-distance, 200px))) scaleY(2);
            }
        }

    </style>
</head>
<body>
    <div id="eyes-stage"></div>

    <div id="spider-stage" class="spider-grid"></div>

    <div id="drips-container"></div>

    <div class="help-message" id="help-message">Space bar for help</div>

    <div class="instructions" id="instructions">
        <h3>Controls</h3>
        <p><kbd>C</kbd> Auto creepy (beast mode)</p>
        <p><kbd>X</kbd> Eye tracking (beast mode)</p>
        <p><kbd>Z</kbd> Custom eyes</p>
        <p><kbd>T</kbd> Toggle tears (drips)</p>
        <p><kbd>D</kbd> Toggle director</p>
        <p><kbd>M</kbd> Director mode (passive/active/chaotic)</p>
        <p><kbd>1-0</kbd> Toggle eye sets (10)</p>
        <p><kbd>B</kbd> Cycle behavior mode</p>
        <p><kbd>S</kbd> Cycle scripts</p>
        <p><kbd>P</kbd> Play default script</p>
        <p><kbd>Esc</kbd> Stop script</p>
        <p><kbd>Q/W</kbd> Scale up/down</p>
        <p><kbd>E/R</kbd> Gap wider/closer</p>
        <p><kbd>↑↓←→</kbd> Move position</p>
        <p><kbd>Space</kbd> Help</p>
    </div>

    <script>
        // Create single spider eye HTML dynamically
        function createSpiderEye(eyeId) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'spider-eye');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.setAttribute('data-eye-id', eyeId);

            svg.innerHTML = `
                <!-- Eye white (circular) with bloodshot veins -->
                <circle cx="50" cy="50" r="48" fill="#fff8f0" stroke="#8b0000" stroke-width="2"/>

                <!-- Blood vessels -->
                <path d="M 50 2 Q 45 20, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 50 98 Q 55 80, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 2 50 Q 20 45, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 98 50 Q 80 55, 50 50" stroke="#8b0000" stroke-width="0.5" fill="none" opacity="0.6"/>
                <path d="M 15 15 Q 30 30, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 85 85 Q 70 70, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 85 15 Q 70 30, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>
                <path d="M 15 85 Q 30 70, 50 50" stroke="#8b0000" stroke-width="0.4" fill="none" opacity="0.5"/>

                <!-- Iris group -->
                <g class="iris">
                    <!-- Large menacing iris with dark red color -->
                    <circle class="iris-main" cx="50" cy="50" r="24" fill="#8b0000" stroke="#4a0000" stroke-width="2"/>
                </g>

                <!-- Black pupil (dilated for menacing effect) -->
                <g class="iris">
                    <circle cx="50" cy="50" r="14" fill="#000"/>
                    <!-- Sinister glint -->
                    <circle cx="45" cy="45" r="2" fill="rgba(255,255,255,0.7)"/>
                </g>
            `;

            return svg;
        }

        // Create eye pair HTML dynamically
        function createEyePair(setId) {
            const container = document.createElement('div');
            container.className = 'eyes-container';
            container.setAttribute('data-set-id', setId);

            container.innerHTML = `
        <!-- Left Eye -->
        <svg class="eye" viewBox="0 0 200 120">
            <!-- Gradients and filters for realistic iris -->
            <defs>
                <radialGradient id="irisGradient1-${setId}" cx="0.3" cy="0.3" r="0.7">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#4CAF50" stop-opacity="0.8"/>
                    <stop class="iris-gradient-stop-2" offset="30%" stop-color="#388E3C" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-3" offset="70%" stop-color="#2E7D32" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#1B5E20" stop-opacity="0.8"/>
                </radialGradient>
                <radialGradient id="irisGradient2-${setId}" cx="0.7" cy="0.4" r="0.6">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#66BB6A" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-2" offset="50%" stop-color="#43A047" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#2E7D32" stop-opacity="0.7"/>
                </radialGradient>
                <radialGradient id="irisGradient3-${setId}" cx="0.5" cy="0.7" r="0.5">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#81C784" stop-opacity="0.5"/>
                    <stop class="iris-gradient-stop-2" offset="60%" stop-color="#4CAF50" stop-opacity="0.3"/>
                    <stop class="iris-gradient-stop-3" offset="100%" stop-color="#388E3C" stop-opacity="0.6"/>
                </radialGradient>
                <filter id="irisBlur-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="1"/>
                </filter>
                <filter id="irisBlur2-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2"/>
                </filter>
            </defs>
            <!-- Eye white (outer oval) -->
            <ellipse class="eye-white" cx="100" cy="60" rx="95" ry="55" fill="white" stroke="#ddd" stroke-width="2"/>

            <!-- Green iris -->
            <g class="iris">
                <!-- Base iris with color-changing gradient -->
                <ellipse class="iris-main" cx="100" cy="60" rx="35" ry="35" fill="#228B22" stroke="#1F5F1F" stroke-width="1"/>
                <!-- Overlapping gradient clouds for texture -->
                <ellipse cx="95" cy="55" rx="28" ry="28" fill="url(#irisGradient1-${setId})" filter="url(#irisBlur-${setId})"/>
                <ellipse cx="105" cy="58" rx="25" ry="25" fill="url(#irisGradient2-${setId})" filter="url(#irisBlur-${setId})"/>
                <ellipse cx="100" cy="65" rx="22" ry="22" fill="url(#irisGradient3-${setId})" filter="url(#irisBlur2-${setId})"/>
                <!-- Additional texture layers -->
                <ellipse cx="92" cy="62" rx="15" ry="15" fill="url(#irisGradient1-${setId})" filter="url(#irisBlur2-${setId})" opacity="0.4"/>
                <ellipse cx="108" cy="55" rx="18" ry="18" fill="url(#irisGradient2-${setId})" filter="url(#irisBlur-${setId})" opacity="0.5"/>
            </g>

            <!-- Black pupil -->
            <g class="iris">
                <ellipse cx="100" cy="60" rx="15" ry="15" fill="#000"/>
                <!-- Lens flare inside pupil -->
                <ellipse cx="95" cy="55" rx="3" ry="4" fill="rgba(255,255,255,0.9)"/>
                <ellipse cx="92" cy="52" rx="1.5" ry="1.5" fill="rgba(255,255,255,0.7)"/>
            </g>
        </svg>

        <!-- Right Eye -->
        <svg class="eye" viewBox="0 0 200 120">
            <!-- Gradients and filters for realistic iris -->
            <defs>
                <radialGradient id="irisGradient1Right-${setId}" cx="0.3" cy="0.3" r="0.7">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#4CAF50" stop-opacity="0.8"/>
                    <stop class="iris-gradient-stop-2" offset="30%" stop-color="#388E3C" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-3" offset="70%" stop-color="#2E7D32" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#1B5E20" stop-opacity="0.8"/>
                </radialGradient>
                <radialGradient id="irisGradient2Right-${setId}" cx="0.7" cy="0.4" r="0.6">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#66BB6A" stop-opacity="0.6"/>
                    <stop class="iris-gradient-stop-2" offset="50%" stop-color="#43A047" stop-opacity="0.4"/>
                    <stop class="iris-gradient-stop-4" offset="100%" stop-color="#2E7D32" stop-opacity="0.7"/>
                </radialGradient>
                <radialGradient id="irisGradient3Right-${setId}" cx="0.5" cy="0.7" r="0.5">
                    <stop class="iris-gradient-stop-1" offset="0%" stop-color="#81C784" stop-opacity="0.5"/>
                    <stop class="iris-gradient-stop-2" offset="60%" stop-color="#4CAF50" stop-opacity="0.3"/>
                    <stop class="iris-gradient-stop-3" offset="100%" stop-color="#388E3C" stop-opacity="0.6"/>
                </radialGradient>
                <filter id="irisBlurRight-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="1"/>
                </filter>
                <filter id="irisBlur2Right-${setId}" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2"/>
                </filter>
            </defs>
            <!-- Eye white (outer oval) -->
            <ellipse class="eye-white" cx="100" cy="60" rx="95" ry="55" fill="white" stroke="#ddd" stroke-width="2"/>

            <!-- Green iris -->
            <g class="iris">
                <!-- Base iris with color-changing gradient -->
                <ellipse class="iris-main" cx="100" cy="60" rx="35" ry="35" fill="#228B22" stroke="#1F5F1F" stroke-width="1"/>
                <!-- Overlapping gradient clouds for texture -->
                <ellipse cx="95" cy="55" rx="28" ry="28" fill="url(#irisGradient1Right-${setId})" filter="url(#irisBlurRight-${setId})"/>
                <ellipse cx="105" cy="58" rx="25" ry="25" fill="url(#irisGradient2Right-${setId})" filter="url(#irisBlurRight-${setId})"/>
                <ellipse cx="100" cy="65" rx="22" ry="22" fill="url(#irisGradient3Right-${setId})" filter="url(#irisBlur2Right-${setId})"/>
                <!-- Additional texture layers -->
                <ellipse cx="92" cy="62" rx="15" ry="15" fill="url(#irisGradient1Right-${setId})" filter="url(#irisBlur2Right-${setId})" opacity="0.4"/>
                <ellipse cx="108" cy="55" rx="18" ry="18" fill="url(#irisGradient2Right-${setId})" filter="url(#irisBlurRight-${setId})" opacity="0.5"/>
            </g>

            <!-- Black pupil -->
            <g class="iris">
                <ellipse cx="100" cy="60" rx="15" ry="15" fill="#000"/>
                <!-- Lens flare inside pupil -->
                <ellipse cx="95" cy="55" rx="3" ry="4" fill="rgba(255,255,255,0.9)"/>
                <ellipse cx="92" cy="52" rx="1.5" ry="1.5" fill="rgba(255,255,255,0.7)"/>
            </g>
        </svg>
`;
            return container;
        }

        // Eye sets state management
        const eyeSets = [];
        let activeSetIndex = -1;
        const maxSets = 10;

        // Spider mode state management
        let isSpiderModeActive = false;
        const spiderEyes = [];
        const spiderEyeCount = 200;

        // Hidden eye indices (corner eyes that are hidden via CSS - don't process these)
        const hiddenEyeIndices = new Set([
            // Row 1
            0, 1, 2, 3, 11, 12, 13,
            // Row 2
            14, 15, 26, 27,
            // Row 3
            28, 29, 41,
            // Row 4
            42, 55,
            // Row 11
            140,
            // Row 12
            154, 166, 167,
            // Row 13
            168, 169, 180, 181,
            // Row 14
            182, 183, 184, 193, 194, 195,
            // Row 15
            196, 197, 198, 199
        ]);

        // Eye tracking state
        let isTrackingMode = false;
        let isAutoMode = false;
        let focalPoint = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let focalPointTarget = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let focalPointAnimationId = null;
        let focalPointTimeoutId = null;
        let autoModeTimeoutId = null;
        let manualControlActive = false;
        let manualControlTimeoutId = null;

        // Arrow key hold state for quadratic acceleration
        let heldArrowKeys = {}; // Tracks held arrow keys: { ArrowUp: timestamp, ... }
        let arrowKeyAnimationId = null; // requestAnimationFrame ID for continuous movement

        // localStorage persistence state
        const localStorageKey = 'eyesAppState';
        let saveStateDebounceTimer = null;

        // Drip toggle state
        let dripsEnabled = true;

        // Gamepad state
        let gamepadAnimationId = null;
        let connectedGamepad = null;

        // ============================================================
        // SCRIPTED BEHAVIOR SYSTEM - Enums and Classes
        // ============================================================

        // Behavior enumeration
        const BehaviorType = {
            AUTONOMOUS: 'autonomous',      // Current random movement (default)
            TRACKING: 'tracking',          // Follow focal point
            SCRIPTED: 'scripted'          // Execute loaded script
        };

        // Script instance class
        class ScriptInstance {
            constructor(scriptObject, setIndex, startTime) {
                this.scriptObject = scriptObject;
                this.setIndex = setIndex;
                this.startTime = startTime;
                this.scheduledActions = [];   // Array of timeout IDs
                this.interactionInstances = []; // Related script instances
                this.isRunning = false;
                this.isInteraction = false;    // Flag to prevent recursive interactions
                this.onComplete = null;        // Callback when script finishes
                this.originalState = null;     // Stores original position/scale/gap to restore
            }
        }

        // Script execution state
        const scriptExecutionState = {
            scriptInstances: new Map(),    // Map<setIndex, ScriptInstance>
            loadedScripts: new Map(),      // Map<scriptId, ScriptObject>
            defaultScripts: {},            // { setIndex: scriptId }
            scriptDirectory: 'scripts/'    // Base path for JSON files
        };

        // Action registry (will be populated in Phase 2)
        const actionRegistry = {};

        // Default values for new eye sets
        const defaultState = {
            scale: 1,
            gap: 20,
            posX: 0,
            posY: 0,
            blinkTimeoutId: null,
            moveTimeoutId: null,
            dripTimeoutId: null,
            everShown: false,
            behavior: BehaviorType.AUTONOMOUS,
            currentScript: null,
            lastBehaviorChange: 0
        };

        // Constants
        const minScale = 0.05;
        const maxScale = 10;
        const scaleStep = 0.05;
        const minGap = -50;
        const maxGap = 200;
        const gapStep = 3;
        const posStep = 40;

        // Arrow key acceleration constants
        const arrowKeyBaseSpeed = 2; // Minimum speed for quick taps (pixels/frame)
        const arrowKeyAcceleration = 150; // Acceleration multiplier for quadratic curve
        const arrowKeyMaxSpeed = 100; // Maximum speed cap (pixels/frame)

        // localStorage constants
        const saveStateDebounceDelay = 500; // Milliseconds to wait before saving state

        // Focal point tracking constants
        const focalPointManualMoveStep = 1000; // Pixels per arrow key press
        const focalPointMoveDelayMin = 3000; // Min milliseconds between random moves
        const focalPointMoveDelayMax = 7000; // Max milliseconds between random moves
        const focalPointSmoothingFactor = 0.65; // Lerp factor for smooth movement
        const manualControlTimeout = 5000; // Milliseconds before resuming auto movement

        // Gamepad constants
        const gamepadDeadzone = 0.15; // Ignore small joystick movements below this threshold
        const gamepadSensitivity = 100; // Multiplier for joystick movement speed

        // Auto mode constants
        const autoModeToggleDelayMin = 4000; // Min milliseconds between mode switches
        const autoModeToggleDelayMax = 12000; // Max milliseconds between mode switches

        // Spider eye animation constants
        const spiderEyeBlinkDelayMin = 4000; // Min milliseconds between blinks
        const spiderEyeBlinkDelayMax = 20000; // Max milliseconds between blinks
        const spiderEyeMoveDelayMin = 1000; // Min milliseconds between iris movements
        const spiderEyeMoveDelayMax = 5000; // Max milliseconds between iris movements
        const spiderEyePulseDurationMin = 3; // Min seconds for pulse animation
        const spiderEyePulseDurationMax = 8; // Max seconds for pulse animation
        const spiderEyeIrisMaxMovement = 12; // Maximum pixels iris can move (random mode)
        const spiderEyeTrackingMaxDistance = 25; // Maximum distance iris moves when tracking
        const spiderEyeTrackingDistanceDivisor = 30; // Divisor for tracking distance calculation

        // Drip animation constants
        const dripPoolSize = 30; // Number of reusable drip elements
        const maxSimultaneousDrips = 15; // Maximum drips active at once
        const dripDelayMinSpider = 5000; // Min milliseconds between drips (spider mode)
        const dripDelayMaxSpider = 12000; // Max milliseconds between drips (spider mode)
        const dripDelayMinNormal = 2000; // Min milliseconds between drips (normal mode)
        const dripDelayMaxNormal = 6000; // Max milliseconds between drips (normal mode)
        const dripDurationMin = 1500; // Min milliseconds for drip fall animation
        const dripDurationMax = 2500; // Max milliseconds for drip fall animation
        const dripColors = ['#7a9b3d', '#9b9b3d', '#8b7a3d', '#9b5a5a', '#7a8b3d']; // Sickly liquid colors

        // Drip object pool management
        const dripPool = [];
        let activeDripCount = 0;

        function initializeDripPool() {
            const container = document.getElementById('drips-container');
            for (let i = 0; i < dripPoolSize; i++) {
                const drip = document.createElement('div');
                drip.className = 'drip';
                container.appendChild(drip);
                dripPool.push({
                    element: drip,
                    inUse: false
                });
            }
        }

        function getAvailableDrip() {
            if (activeDripCount >= maxSimultaneousDrips) return null;

            for (let i = 0; i < dripPool.length; i++) {
                if (!dripPool[i].inUse) {
                    dripPool[i].inUse = true;
                    activeDripCount++;
                    return dripPool[i];
                }
            }
            return null;
        }

        function releaseDrip(dripData) {
            if (!dripData) return;
            dripData.inUse = false;
            dripData.element.classList.remove('active');
            dripData.element.style.cssText = '';
            activeDripCount--;
        }

        function spawnDrip(x, y) {
            const dripData = getAvailableDrip();
            if (!dripData) return; // Pool exhausted or max limit reached

            const drip = dripData.element;

            // Random drip properties
            const color = dripColors[Math.floor(Math.random() * dripColors.length)];
            const width = Math.random() * 6 + 4; // 4-10px
            const height = Math.random() * 10 + 8; // 8-18px
            const duration = Math.random() * (dripDurationMax - dripDurationMin) + dripDurationMin;
            const fallDistance = Math.random() * 150 + 150; // 150-300px
            const driftX = (Math.random() - 0.5) * 30; // -15 to 15px horizontal drift

            // Set CSS custom properties and styles
            drip.style.cssText = `
                --drip-color: ${color};
                --drip-duration: ${duration}ms;
                --start-x: 0px;
                --start-y: 0px;
                --fall-distance: ${fallDistance}px;
                --drift-x: ${driftX}px;
                width: ${width}px;
                height: ${height}px;
                left: ${x}px;
                top: ${y}px;
            `;

            // Start animation
            drip.classList.add('active');

            // Release drip after animation completes
            setTimeout(() => {
                releaseDrip(dripData);
            }, duration);
        }

        // Generate random spawn position
        function getRandomSpawnPosition() {
            const randomX = (Math.random() - 0.5) * 800; // -400 to 400
            const randomY = (Math.random() - 0.5) * 400; // -200 to 200
            return { posX: randomX, posY: randomY };
        }

        // ============================================================
        // SCRIPT LOADING SYSTEM
        // ============================================================

        // Load script from JSON file
        async function loadScript(scriptId) {
            if (scriptExecutionState.loadedScripts.has(scriptId)) {
                return scriptExecutionState.loadedScripts.get(scriptId);
            }

            try {
                const response = await fetch(`${scriptExecutionState.scriptDirectory}${scriptId}.json`);
                if (!response.ok) throw new Error(`Script not found: ${scriptId}`);

                const scriptObject = await response.json();

                // Validate script structure
                if (!validateScript(scriptObject)) {
                    throw new Error(`Invalid script format: ${scriptId}`);
                }

                // Sort timeline by time
                scriptObject.timeline.sort((a, b) => a.time - b.time);

                // Calculate duration if not provided
                if (!scriptObject.duration) {
                    const lastAction = scriptObject.timeline[scriptObject.timeline.length - 1];
                    scriptObject.duration = lastAction.time + (lastAction.params?.duration || 0);
                }

                scriptExecutionState.loadedScripts.set(scriptId, scriptObject);
                console.log(`Loaded script: ${scriptObject.name} (${scriptId})`);

                return scriptObject;
            } catch (error) {
                console.error(`Failed to load script ${scriptId}:`, error);
                return null;
            }
        }

        // Validate script structure
        function validateScript(script) {
            if (!script.scriptId || !script.name || !Array.isArray(script.timeline)) {
                return false;
            }

            for (const action of script.timeline) {
                if (typeof action.time !== 'number' || !action.action) {
                    return false;
                }
            }

            return true;
        }

        // Preload all scripts in directory
        async function preloadAllScripts() {
            const scriptList = [
                'surprise', 'cross_eyes', 'roll_eyes', 'sleepy',
                'angry', 'curious', 'scared', 'confused', 'shifty',
                'sync_blink', 'wave', 'conversation', 'conversation_partner', 'dance',
                'rainbow', 'disco', 'slot_machine', 'orbit', 'orbit_reverse'
            ];

            const promises = scriptList.map(id => loadScript(id));
            await Promise.allSettled(promises);
        }

        // ============================================================
        // SCRIPT EXECUTION ENGINE
        // ============================================================

        // Start executing a script on an eye set
        async function executeScript(setIndex, scriptId, isInteraction = false) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return null;

            // Load script if not already loaded
            const scriptObject = await loadScript(scriptId);
            if (!scriptObject) return null;

            // Stop current behavior (animations, tracking, or existing script)
            if (eyeSet.behavior === BehaviorType.SCRIPTED && eyeSet.currentScript) {
                stopScript(setIndex);
            } else if (eyeSet.behavior === BehaviorType.TRACKING) {
                stopEyeSetTracking(setIndex);
            } else {
                stopEyeSetAnimations(setIndex);
            }

            // Set behavior to scripted
            eyeSet.behavior = BehaviorType.SCRIPTED;
            eyeSet.lastBehaviorChange = Date.now();

            // Create script instance
            const instance = new ScriptInstance(scriptObject, setIndex, Date.now());
            instance.isRunning = true;
            instance.isInteraction = isInteraction;

            // Store original state to restore after script completes
            instance.originalState = {
                posX: eyeSet.posX,
                posY: eyeSet.posY,
                scale: eyeSet.scale,
                gap: eyeSet.gap
            };

            eyeSet.currentScript = instance;
            scriptExecutionState.scriptInstances.set(setIndex, instance);

            // Schedule all timeline actions
            for (const actionDef of scriptObject.timeline) {
                const timeoutId = setTimeout(() => {
                    executeAction(setIndex, actionDef.action, actionDef.params || {});
                }, actionDef.time * 1000);

                instance.scheduledActions.push(timeoutId);
            }

            // Handle interactions ONLY if this is not already an interaction
            // This prevents infinite interaction loops
            if (scriptObject.interactions && !isInteraction) {
                for (const interaction of scriptObject.interactions) {
                    const interactionTimeoutId = setTimeout(async () => {
                        const targetScript = interaction.scriptId || scriptId;
                        const interactionInstance = await executeScript(interaction.targetSet, targetScript, true);
                        if (interactionInstance) {
                            instance.interactionInstances.push(interactionInstance);
                        }
                    }, interaction.startTime * 1000);

                    instance.scheduledActions.push(interactionTimeoutId);
                }
            }

            // Schedule script completion
            const completionTimeoutId = setTimeout(() => {
                completeScript(setIndex);
            }, scriptObject.duration * 1000);

            instance.scheduledActions.push(completionTimeoutId);

            console.log(`Started script "${scriptObject.name}" on eye set ${setIndex}${isInteraction ? ' (interaction)' : ''}`);
            return instance;
        }

        // Complete script execution
        function completeScript(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.currentScript) return;

            const instance = eyeSet.currentScript;

            // Clear all scheduled actions
            for (const timeoutId of instance.scheduledActions) {
                clearTimeout(timeoutId);
            }

            instance.isRunning = false;
            instance.scheduledActions = [];

            // Execute completion callback if present
            if (instance.onComplete) {
                instance.onComplete();
            }

            // Clean up
            eyeSet.currentScript = null;
            scriptExecutionState.scriptInstances.delete(setIndex);

            console.log(`Completed script "${instance.scriptObject.name}" on eye set ${setIndex}`);

            // Restore original position, scale, and gap if they were stored
            if (instance.originalState) {
                eyeSet.posX = instance.originalState.posX;
                eyeSet.posY = instance.originalState.posY;
                eyeSet.scale = instance.originalState.scale;
                eyeSet.gap = instance.originalState.gap;
                updateEyeSetTransform(setIndex);
            }

            // IMPORTANT: Stop all existing animations/timers first to prevent multiple behaviors
            stopEyeSetAnimations(setIndex);

            // Return to autonomous behavior
            eyeSet.behavior = BehaviorType.AUTONOMOUS;
            eyeSet.lastBehaviorChange = Date.now();

            // Start fresh autonomous animations
            startEyeSetAnimations(setIndex);
        }

        // Stop script execution (manual interrupt)
        function stopScript(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.currentScript) return;

            completeScript(setIndex);
        }

        // Execute a single action
        function executeAction(setIndex, actionName, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            // Resolve action function
            const actionFunction = actionRegistry[actionName];
            if (!actionFunction) {
                console.warn(`Unknown action: ${actionName}`);
                return;
            }

            // Call action with eye set and parameters
            actionFunction(setIndex, params);
        }

        // ============================================================
        // PHASE 2: CORE ACTION FUNCTIONS
        // ============================================================

        // Blink action
        function actionBlink(setIndex, params) {
            blinkEyeSet(setIndex);
        }

        // Move iris to specific position
        function actionMoveIris(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { x = 0, y = 0, duration = 1.5 } = params;
            const irises = eyeSet.element.querySelectorAll('.iris');

            // Update CSS transition duration
            irises.forEach(iris => {
                iris.style.transition = `transform ${duration}s ease-out`;
                iris.style.transform = `translate(${x}px, ${y}px)`;
            });
        }

        // Set scale with animation
        function actionSetScale(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { scale, duration = 0.3 } = params;

            // Temporarily override transition for smooth animation
            const originalTransition = eyeSet.element.style.transition;
            eyeSet.element.style.transition = `transform ${duration}s ease-out, gap ${duration}s ease-out`;

            eyeSet.scale = Math.max(minScale, Math.min(scale, maxScale));
            updateEyeSetTransform(setIndex);

            // Restore original transition after animation
            setTimeout(() => {
                eyeSet.element.style.transition = originalTransition;
            }, duration * 1000);
        }

        // Set gap with animation
        function actionSetGap(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { gap, duration = 0.3 } = params;

            const originalTransition = eyeSet.element.style.transition;
            eyeSet.element.style.transition = `transform ${duration}s ease-out, gap ${duration}s ease-out`;

            eyeSet.gap = Math.max(minGap, Math.min(gap, maxGap));
            updateEyeSetTransform(setIndex);

            setTimeout(() => {
                eyeSet.element.style.transition = originalTransition;
            }, duration * 1000);
        }

        // Set position with animation
        function actionSetPosition(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { x, y, duration = 0.5 } = params;

            const originalTransition = eyeSet.element.style.transition;
            eyeSet.element.style.transition = `transform ${duration}s ease-out, gap ${duration}s ease-out`;

            if (x !== undefined) eyeSet.posX = x;
            if (y !== undefined) eyeSet.posY = y;
            updateEyeSetTransform(setIndex);

            setTimeout(() => {
                eyeSet.element.style.transition = originalTransition;
            }, duration * 1000);
        }

        // Play sound file
        function actionPlaySound(setIndex, params) {
            const { soundFile, volume = 1.0 } = params;

            try {
                const audio = new Audio(soundFile);
                audio.volume = Math.max(0, Math.min(volume, 1));
                audio.play().catch(err => console.warn('Audio play failed:', err));
            } catch (error) {
                console.error('Failed to play sound:', error);
            }
        }

        // Populate action registry with core actions
        actionRegistry['blink'] = actionBlink;
        actionRegistry['moveIris'] = actionMoveIris;
        actionRegistry['setScale'] = actionSetScale;
        actionRegistry['setGap'] = actionSetGap;
        actionRegistry['setPosition'] = actionSetPosition;
        actionRegistry['playSound'] = actionPlaySound;

        // ============================================================
        // PHASE 3: ADVANCED ACTION FUNCTIONS
        // ============================================================

        // Cross eyes toward center
        function actionCrossEyes(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { intensity = 0.5, duration = 0.8 } = params;
            const leftEyeIrises = eyeSet.element.querySelectorAll('svg:first-child .iris');
            const rightEyeIrises = eyeSet.element.querySelectorAll('svg:last-child .iris');

            const crossAmount = 40 * intensity; // Max 40px inward movement

            leftEyeIrises.forEach(iris => {
                iris.style.transition = `transform ${duration}s ease-out`;
                iris.style.transform = `translate(${crossAmount}px, 0px)`;
            });

            rightEyeIrises.forEach(iris => {
                iris.style.transition = `transform ${duration}s ease-out`;
                iris.style.transform = `translate(${-crossAmount}px, 0px)`;
            });
        }

        // Uncross eyes (return to center)
        function actionUncrossEyes(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { duration = 0.5 } = params;
            const irises = eyeSet.element.querySelectorAll('.iris');

            irises.forEach(iris => {
                iris.style.transition = `transform ${duration}s ease-out`;
                iris.style.transform = 'translate(0px, 0px)';
            });
        }

        // Roll eyes in circular motion
        function actionRollEyes(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { direction = 'up', duration = 1.5 } = params;
            const irises = eyeSet.element.querySelectorAll('.iris');

            // Define roll path (circular motion)
            const radius = 45;
            const steps = 8;
            const stepDuration = duration / steps;

            // Starting angle based on direction
            let startAngle = direction === 'up' ? -Math.PI/2 : Math.PI/2;
            if (direction === 'left') startAngle = Math.PI;
            if (direction === 'right') startAngle = 0;

            // Animate through circular path
            for (let i = 0; i <= steps; i++) {
                setTimeout(() => {
                    const angle = startAngle + (i / steps) * 2 * Math.PI;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius * 0.3; // Elliptical for eye shape

                    irises.forEach(iris => {
                        iris.style.transition = `transform ${stepDuration}s linear`;
                        iris.style.transform = `translate(${x}px, ${y}px)`;
                    });
                }, i * stepDuration * 1000);
            }
        }

        // Widen eyes (surprise effect)
        function actionWiden(setIndex, params) {
            const { intensity = 0.5, duration = 0.3 } = params;
            const scaleIncrease = 1 + (intensity * 0.5); // Up to 1.5x scale
            actionSetScale(setIndex, { scale: scaleIncrease, duration });
        }

        // Squint eyes
        function actionSquint(setIndex, params) {
            const { intensity = 0.5, duration = 0.3 } = params;
            const scaleDecrease = 1 - (intensity * 0.3); // Down to 0.7x scale
            actionSetScale(setIndex, { scale: scaleDecrease, duration });
        }

        // Look at specific screen coordinates
        function actionLookAt(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { screenX, screenY, duration = 0.8 } = params;

            // Get eye position on screen
            const rect = eyeSet.element.getBoundingClientRect();
            const eyeCenterX = rect.left + rect.width / 2;
            const eyeCenterY = rect.top + rect.height / 2;

            // Calculate iris offset
            const dx = screenX - eyeCenterX;
            const dy = screenY - eyeCenterY;
            const angle = Math.atan2(dy, dx);
            const distance = Math.min(50, Math.sqrt(dx * dx + dy * dy) / 20);

            const offsetX = Math.cos(angle) * distance;
            const offsetY = Math.sin(angle) * distance * 0.2; // Less vertical movement

            actionMoveIris(setIndex, { x: offsetX, y: offsetY, duration });
        }

        // Quick darting movement
        function actionDart(setIndex, params) {
            const { direction = 'random', duration = 0.15 } = params;

            let x = 0, y = 0;
            if (direction === 'random') {
                x = (Math.random() - 0.5) * 100;
                y = (Math.random() - 0.5) * 20;
            } else if (direction === 'left') {
                x = -50;
            } else if (direction === 'right') {
                x = 50;
            } else if (direction === 'up') {
                y = -10;
            } else if (direction === 'down') {
                y = 10;
            }

            actionMoveIris(setIndex, { x, y, duration });
        }

        // Shake eyes rapidly
        function actionShake(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { intensity = 0.5, duration = 0.5, frequency = 10 } = params;
            const shakeAmount = 20 * intensity;
            const interval = duration / frequency;

            for (let i = 0; i < frequency; i++) {
                setTimeout(() => {
                    const x = (Math.random() - 0.5) * 2 * shakeAmount;
                    const y = (Math.random() - 0.5) * 2 * shakeAmount * 0.3;
                    actionMoveIris(setIndex, { x, y, duration: interval });
                }, i * interval * 1000);
            }
        }

        // Start dripping
        function actionStartDripping(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            if (!eyeSet.dripTimeoutId) {
                const initialDripDelay = Math.random() * 1000 + 500;
                eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(setIndex), initialDripDelay);
            }
        }

        // Stop dripping
        function actionStopDripping(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            if (eyeSet.dripTimeoutId) {
                clearTimeout(eyeSet.dripTimeoutId);
                eyeSet.dripTimeoutId = null;
            }
        }

        // Set iris color
        function actionSetColor(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { color } = params;

            // Pause color animations
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = 'none';
                elem.style.fill = color;
            });
        }

        // Fade color over time
        function actionFadeColor(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { fromColor, toColor, duration = 1.0 } = params;

            // Use CSS transition for color fade
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = 'none';
                elem.style.fill = fromColor;
                elem.style.transition = `fill ${duration}s ease-in-out`;

                // Trigger fade
                setTimeout(() => {
                    elem.style.fill = toColor;
                }, 10);
            });
        }

        // Smooth orbital motion around eye edges
        function actionOrbitIris(setIndex, params) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const {
                duration = 3.0,           // Duration for one complete orbit
                clockwise = true,         // Direction of rotation
                radiusX = 50,            // Horizontal radius (max x displacement)
                radiusY = 10,            // Vertical radius (max y displacement)
                revolutions = 1          // Number of complete orbits
            } = params;

            const startTime = performance.now();
            const totalDuration = duration * revolutions * 1000; // Convert to ms

            // Store animation ID so it can be cancelled
            if (!eyeSet.orbitAnimationId) {
                eyeSet.orbitAnimationId = null;
            }

            // Cancel any existing orbit animation
            if (eyeSet.orbitAnimationId) {
                cancelAnimationFrame(eyeSet.orbitAnimationId);
            }

            function updateOrbit(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / totalDuration, 1.0);

                // Calculate angle (0 to 2π * revolutions)
                let angle = progress * Math.PI * 2 * revolutions;
                if (!clockwise) angle = -angle;

                // Calculate position on ellipse
                const x = Math.cos(angle) * radiusX;
                const y = Math.sin(angle) * radiusY;

                // Apply transform to iris groups
                const irisGroups = eyeSet.element.querySelectorAll('.iris');
                irisGroups.forEach(iris => {
                    iris.style.transform = `translate(${x}px, ${y}px)`;
                    iris.style.transition = 'none'; // Disable CSS transitions for smooth frame-by-frame updates
                });

                // Continue animation if not complete
                if (progress < 1.0) {
                    eyeSet.orbitAnimationId = requestAnimationFrame(updateOrbit);
                } else {
                    eyeSet.orbitAnimationId = null;
                }
            }

            eyeSet.orbitAnimationId = requestAnimationFrame(updateOrbit);
        }

        // Populate action registry with advanced actions
        actionRegistry['crossEyes'] = actionCrossEyes;
        actionRegistry['uncrossEyes'] = actionUncrossEyes;
        actionRegistry['rollEyes'] = actionRollEyes;
        actionRegistry['widen'] = actionWiden;
        actionRegistry['squint'] = actionSquint;
        actionRegistry['lookAt'] = actionLookAt;
        actionRegistry['dart'] = actionDart;
        actionRegistry['shake'] = actionShake;
        actionRegistry['startDripping'] = actionStartDripping;
        actionRegistry['stopDripping'] = actionStopDripping;
        actionRegistry['setColor'] = actionSetColor;
        actionRegistry['fadeColor'] = actionFadeColor;
        actionRegistry['orbitIris'] = actionOrbitIris;

        // ============================================================
        // PHASE 5: BEHAVIOR MANAGEMENT
        // ============================================================

        // Per-eye-set tracking state (shared across all tracking eye sets)
        const eyeSetTrackingState = {
            focalPoint: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            focalPointTarget: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            animationId: null,
            moveTimeoutId: null
        };

        // Set behavior mode for an eye set
        function setEyeBehavior(setIndex, behavior) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Always stop all animations first, regardless of current behavior
            // This ensures clean transitions and prevents multiple timers
            stopEyeSetAnimations(setIndex);

            // Then stop specific behaviors
            if (eyeSet.behavior === BehaviorType.SCRIPTED && eyeSet.currentScript) {
                stopScript(setIndex);
            } else if (eyeSet.behavior === BehaviorType.TRACKING) {
                stopEyeSetTracking(setIndex);
            }

            // Start new behavior
            eyeSet.behavior = behavior;
            eyeSet.lastBehaviorChange = Date.now();

            switch (behavior) {
                case BehaviorType.AUTONOMOUS:
                    startEyeSetAnimations(setIndex);
                    break;

                case BehaviorType.TRACKING:
                    startEyeSetTracking(setIndex);
                    break;

                case BehaviorType.SCRIPTED:
                    // Scripts started via executeScript()
                    break;
            }

            debouncedSaveState();
        }

        // Cycle through behaviors (for keyboard control)
        function cycleBehavior(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const behaviors = [
                BehaviorType.AUTONOMOUS,
                BehaviorType.TRACKING,
                BehaviorType.SCRIPTED
            ];

            const currentIndex = behaviors.indexOf(eyeSet.behavior);
            const nextIndex = (currentIndex + 1) % behaviors.length;
            const nextBehavior = behaviors[nextIndex];

            if (nextBehavior === BehaviorType.SCRIPTED) {
                // Load default script or cycle to next behavior
                const defaultScript = scriptExecutionState.defaultScripts[setIndex];
                if (defaultScript) {
                    executeScript(setIndex, defaultScript);
                } else {
                    // No default script, cycle to autonomous instead
                    setEyeBehavior(setIndex, BehaviorType.AUTONOMOUS);
                }
            } else {
                setEyeBehavior(setIndex, nextBehavior);
            }
        }

        // Cycle through available scripts
        function cycleScript(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const scriptIds = Array.from(scriptExecutionState.loadedScripts.keys());
            if (scriptIds.length === 0) return;

            // Find current script index
            let currentIndex = -1;
            if (eyeSet.currentScript) {
                currentIndex = scriptIds.indexOf(eyeSet.currentScript.scriptObject.scriptId);
            }

            // Get next script
            const nextIndex = (currentIndex + 1) % scriptIds.length;
            const nextScriptId = scriptIds[nextIndex];

            // Execute next script
            executeScript(setIndex, nextScriptId);
        }

        // Start tracking mode for an individual eye set
        function startEyeSetTracking(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            eyeSet.behavior = BehaviorType.TRACKING;
            eyeSet.lastBehaviorChange = Date.now();

            // Initialize focal point if not already tracking
            if (!eyeSetTrackingState.animationId) {
                eyeSetTrackingState.focalPoint = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };
                eyeSetTrackingState.focalPointTarget = {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                };

                // Start movement
                moveEyeSetFocalPoint();

                // Start tracking loop
                eyeSetTrackingState.animationId = requestAnimationFrame(updateEyeSetTracking);
            }
        }

        // Stop tracking mode for an individual eye set
        function stopEyeSetTracking(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Check if any other sets are still tracking
            const hasOtherTracking = eyeSets.some((set, idx) =>
                set && idx !== setIndex && set.behavior === BehaviorType.TRACKING
            );

            // If no other sets tracking, stop global tracking
            if (!hasOtherTracking && eyeSetTrackingState.animationId) {
                cancelAnimationFrame(eyeSetTrackingState.animationId);
                eyeSetTrackingState.animationId = null;

                if (eyeSetTrackingState.moveTimeoutId) {
                    clearTimeout(eyeSetTrackingState.moveTimeoutId);
                    eyeSetTrackingState.moveTimeoutId = null;
                }
            }
        }

        // Update eye set tracking animation
        function updateEyeSetTracking() {
            // Update focal point position
            eyeSetTrackingState.focalPoint.x += (eyeSetTrackingState.focalPointTarget.x - eyeSetTrackingState.focalPoint.x) * focalPointSmoothingFactor;
            eyeSetTrackingState.focalPoint.y += (eyeSetTrackingState.focalPointTarget.y - eyeSetTrackingState.focalPoint.y) * focalPointSmoothingFactor;

            // Update all eye sets in tracking mode
            eyeSets.forEach((eyeSet, setIndex) => {
                if (!eyeSet || !eyeSet.visible || eyeSet.behavior !== BehaviorType.TRACKING) return;

                // Get eye position
                const rect = eyeSet.element.getBoundingClientRect();
                const eyeCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                // Calculate vector to focal point
                const dx = eyeSetTrackingState.focalPoint.x - eyeCenter.x;
                const dy = eyeSetTrackingState.focalPoint.y - eyeCenter.y;

                // Calculate angle and distance
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const distance = Math.min(50, dist / 15);

                // Calculate iris offset
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance * 0.2;

                // Apply to iris elements
                const irises = eyeSet.element.querySelectorAll('.iris');
                irises.forEach(iris => {
                    iris.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                });
            });

            // Continue loop
            eyeSetTrackingState.animationId = requestAnimationFrame(updateEyeSetTracking);
        }

        // Move focal point to random position
        function moveEyeSetFocalPoint() {
            // Generate random target position
            eyeSetTrackingState.focalPointTarget = {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight
            };

            // Schedule next move
            const nextMoveDelay = Math.random() * (focalPointMoveDelayMax - focalPointMoveDelayMin) + focalPointMoveDelayMin;
            eyeSetTrackingState.moveTimeoutId = setTimeout(moveEyeSetFocalPoint, nextMoveDelay);
        }

        // ============================================================
        // PHASE 10: DIRECTOR SYSTEM
        // ============================================================

        // Director state
        const directorState = {
            enabled: false,
            mode: 'active',
            lastScriptTime: 0,
            scriptCooldown: 5000,
            evaluationInterval: 8000,
            evaluationTimeoutId: null,
            triggerProbabilities: {
                autonomous: 0.5,
                tracking: 0.2,
                scripted: 0.3
            },
            interactionChance: 0.3
        };

        // Director configuration
        const directorConfig = {
            defaultMode: 'active',
            modes: {
                passive: {
                    evaluationInterval: 12000,
                    scriptCooldown: 10000,
                    triggerProbabilities: { autonomous: 0.8, tracking: 0.1, scripted: 0.1 }
                },
                active: {
                    evaluationInterval: 8000,
                    scriptCooldown: 5000,
                    triggerProbabilities: { autonomous: 0.5, tracking: 0.2, scripted: 0.3 }
                },
                chaotic: {
                    evaluationInterval: 4000,
                    scriptCooldown: 2000,
                    triggerProbabilities: { autonomous: 0.2, tracking: 0.3, scripted: 0.5 }
                }
            },
            scriptWeights: {
                surprise: 1.0,
                cross_eyes: 0.8,
                roll_eyes: 0.9,
                sleepy: 0.6,
                angry: 0.7,
                curious: 0.9,
                scared: 0.7,
                confused: 0.8,
                shifty: 1.5,
                sync_blink: 1.2,
                wave: 1.0,
                conversation: 1.5,
                dance: 1.2
            },
            conditions: {
                multipleEyesVisible: {
                    minEyes: 2,
                    scriptPreferences: ['conversation', 'sync_blink', 'wave', 'dance']
                },
                singleEyeVisible: {
                    scriptPreferences: ['surprise', 'roll_eyes', 'sleepy', 'angry', 'curious', 'scared', 'shifty']
                }
            }
        };

        // Start the director
        function startDirector(mode = 'active') {
            if (directorState.enabled) return;

            directorState.enabled = true;
            directorState.mode = mode;

            // Apply mode configuration
            const modeConfig = directorConfig.modes[mode];
            if (modeConfig) {
                directorState.evaluationInterval = modeConfig.evaluationInterval;
                directorState.scriptCooldown = modeConfig.scriptCooldown;
                directorState.triggerProbabilities = { ...modeConfig.triggerProbabilities };
            }

            console.log(`Director started in ${mode} mode`);
            scheduleDirectorEvaluation();
        }

        // Stop the director
        function stopDirector() {
            if (!directorState.enabled) return;

            directorState.enabled = false;

            if (directorState.evaluationTimeoutId) {
                clearTimeout(directorState.evaluationTimeoutId);
                directorState.evaluationTimeoutId = null;
            }

            console.log('Director stopped');
        }

        // Main director evaluation loop
        function evaluateDirector() {
            if (!directorState.enabled) return;

            const now = Date.now();

            // Get all visible eye sets
            const visibleSets = eyeSets
                .map((set, idx) => ({ set, idx }))
                .filter(({ set }) => set && set.visible);

            if (visibleSets.length === 0) {
                scheduleDirectorEvaluation();
                return;
            }

            // Check cooldown
            if (now - directorState.lastScriptTime < directorState.scriptCooldown) {
                scheduleDirectorEvaluation();
                return;
            }

            // Evaluate each visible eye set
            for (const { set, idx } of visibleSets) {
                // NEVER interrupt a running script - this is critical!
                if (set.behavior === BehaviorType.SCRIPTED && set.currentScript) {
                    continue;
                }

                // Skip if recently changed behavior (cooldown period)
                if (now - set.lastBehaviorChange < 3000) {
                    continue;
                }

                // Decide action based on probabilities
                const action = weightedRandomChoice(directorState.triggerProbabilities);

                switch (action) {
                    case 'autonomous':
                        if (set.behavior !== BehaviorType.AUTONOMOUS) {
                            setEyeBehavior(idx, BehaviorType.AUTONOMOUS);
                        }
                        break;

                    case 'tracking':
                        if (set.behavior !== BehaviorType.TRACKING) {
                            setEyeBehavior(idx, BehaviorType.TRACKING);
                        }
                        break;

                    case 'scripted':
                        triggerDirectorScript(idx, visibleSets);
                        directorState.lastScriptTime = now;
                        break;
                }
            }

            scheduleDirectorEvaluation();
        }

        // Schedule next director evaluation
        function scheduleDirectorEvaluation() {
            if (!directorState.enabled) return;

            // Add some randomness to evaluation timing
            const jitter = Math.random() * 2000 - 1000; // ±1 second
            const delay = directorState.evaluationInterval + jitter;

            directorState.evaluationTimeoutId = setTimeout(evaluateDirector, delay);
        }

        // Trigger a script chosen by the director
        function triggerDirectorScript(setIndex, visibleSets) {
            // Determine if this should be an interaction
            const shouldInteract = visibleSets.length > 1 &&
                                   Math.random() < directorState.interactionChance;

            let scriptId;

            if (shouldInteract) {
                // Choose interaction script
                const interactionScripts = directorConfig.conditions.multipleEyesVisible.scriptPreferences;
                scriptId = weightedRandomScriptChoice(interactionScripts);
            } else {
                // Choose solo script
                const soloScripts = directorConfig.conditions.singleEyeVisible.scriptPreferences;
                scriptId = weightedRandomScriptChoice(soloScripts);
            }

            if (scriptId) {
                console.log(`Director triggering script "${scriptId}" on eye set ${setIndex}`);
                executeScript(setIndex, scriptId);
            }
        }

        // Weighted random choice from probability distribution
        function weightedRandomChoice(weights) {
            const rand = Math.random();
            let cumulative = 0;

            for (const [choice, probability] of Object.entries(weights)) {
                cumulative += probability;
                if (rand < cumulative) {
                    return choice;
                }
            }

            return Object.keys(weights)[0]; // Fallback
        }

        // Weighted random script selection
        function weightedRandomScriptChoice(scriptIds) {
            // Filter to loaded scripts with weights
            const available = scriptIds.filter(id =>
                scriptExecutionState.loadedScripts.has(id) &&
                directorConfig.scriptWeights[id] !== undefined
            );

            if (available.length === 0) return null;

            // Calculate total weight
            const totalWeight = available.reduce((sum, id) =>
                sum + (directorConfig.scriptWeights[id] || 1.0), 0
            );

            // Weighted random selection
            let rand = Math.random() * totalWeight;

            for (const scriptId of available) {
                const weight = directorConfig.scriptWeights[scriptId] || 1.0;
                rand -= weight;
                if (rand <= 0) {
                    return scriptId;
                }
            }

            return available[0]; // Fallback
        }

        // Change director mode
        function setDirectorMode(mode) {
            if (!directorConfig.modes[mode]) {
                console.error(`Unknown director mode: ${mode}`);
                return;
            }

            const wasEnabled = directorState.enabled;

            if (wasEnabled) {
                stopDirector();
            }

            directorState.mode = mode;

            if (wasEnabled) {
                startDirector(mode);
            }

            console.log(`Director mode changed to: ${mode}`);
        }

        // Gamepad functions
        function pollGamepad() {
            if (!isTrackingMode) {
                if (gamepadAnimationId) {
                    cancelAnimationFrame(gamepadAnimationId);
                    gamepadAnimationId = null;
                }
                return;
            }

            const gamepads = navigator.getGamepads();
            let activeGamepad = null;

            // Find first connected gamepad
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    activeGamepad = gamepads[i];
                    break;
                }
            }

            if (activeGamepad) {
                // Read left stick axes (axes[0] = X, axes[1] = Y)
                const axisX = activeGamepad.axes[0];
                const axisY = activeGamepad.axes[1];

                // Apply deadzone
                const deadzonedX = Math.abs(axisX) > gamepadDeadzone ? axisX : 0;
                const deadzonedY = Math.abs(axisY) > gamepadDeadzone ? axisY : 0;

                // If joystick is moved, update focal point
                if (deadzonedX !== 0 || deadzonedY !== 0) {
                    const dx = deadzonedX * gamepadSensitivity;
                    const dy = deadzonedY * gamepadSensitivity;
                    moveFocalPointManually(dx, dy);
                }
            }

            // Continue polling
            gamepadAnimationId = requestAnimationFrame(pollGamepad);
        }

        function startGamepadPolling() {
            if (!gamepadAnimationId && isTrackingMode) {
                gamepadAnimationId = requestAnimationFrame(pollGamepad);
            }
        }

        function stopGamepadPolling() {
            if (gamepadAnimationId) {
                cancelAnimationFrame(gamepadAnimationId);
                gamepadAnimationId = null;
            }
        }

        // Focal point tracking functions
        function moveFocalPoint() {
            if (!isSpiderModeActive || !isTrackingMode || manualControlActive) return;

            // Generate random target position
            focalPointTarget = {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight
            };

            // Schedule next move
            const nextMoveDelay = Math.random() * (focalPointMoveDelayMax - focalPointMoveDelayMin) + focalPointMoveDelayMin;
            focalPointTimeoutId = setTimeout(moveFocalPoint, nextMoveDelay);
        }

        function startManualControl() {
            if (!isTrackingMode) return;

            manualControlActive = true;

            // Stop random focal point movement
            if (focalPointTimeoutId) {
                clearTimeout(focalPointTimeoutId);
                focalPointTimeoutId = null;
            }

            // Reset the 5-second timer
            if (manualControlTimeoutId) {
                clearTimeout(manualControlTimeoutId);
            }

            manualControlTimeoutId = setTimeout(() => {
                manualControlActive = false;
                // Resume random movement
                moveFocalPoint();
            }, manualControlTimeout);
        }

        function moveFocalPointManually(dx, dy) {
            if (!isTrackingMode) return;

            startManualControl();

            // Move the focal point target
            focalPointTarget.x = Math.max(0, Math.min(window.innerWidth, focalPointTarget.x + dx));
            focalPointTarget.y = Math.max(0, Math.min(window.innerHeight, focalPointTarget.y + dy));
        }

        function updateFocalPointPosition() {
            if (!isTrackingMode) return;

            // Smoothly interpolate toward target
            focalPoint.x += (focalPointTarget.x - focalPoint.x) * focalPointSmoothingFactor;
            focalPoint.y += (focalPointTarget.y - focalPoint.y) * focalPointSmoothingFactor;
        }

        function updateEyeTracking() {
            if (!isSpiderModeActive || !isTrackingMode) return;

            // Update focal point position
            updateFocalPointPosition();

            // Update all visible spider eyes (hidden corner eyes are excluded from array)
            spiderEyes.forEach((eyeData, index) => {
                if (!eyeData || !eyeData.element) return;

                // Get eye position
                const rect = eyeData.element.getBoundingClientRect();
                const eyeCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                // Calculate vector to focal point
                const dx = focalPoint.x - eyeCenter.x;
                const dy = focalPoint.y - eyeCenter.y;

                // Calculate angle and distance
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const distance = Math.min(spiderEyeTrackingMaxDistance, dist / spiderEyeTrackingDistanceDivisor);

                // Calculate iris offset
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                // Apply to iris elements
                const irises = eyeData.element.querySelectorAll('.iris');
                irises.forEach(iris => {
                    iris.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                });
            });

            // Continue loop
            focalPointAnimationId = requestAnimationFrame(updateEyeTracking);
        }

        function startFocalPointTracking() {
            if (isTrackingMode) return;

            isTrackingMode = true;

            // Initialize focal point at center
            focalPoint = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            focalPointTarget = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

            // Start movement
            moveFocalPoint();

            // Start tracking loop
            focalPointAnimationId = requestAnimationFrame(updateEyeTracking);

            // Start gamepad polling
            startGamepadPolling();
        }

        function stopFocalPointTracking() {
            if (!isTrackingMode) return;

            isTrackingMode = false;

            // Stop movement timer
            if (focalPointTimeoutId) {
                clearTimeout(focalPointTimeoutId);
                focalPointTimeoutId = null;
            }

            // Stop manual control timer
            if (manualControlTimeoutId) {
                clearTimeout(manualControlTimeoutId);
                manualControlTimeoutId = null;
            }
            manualControlActive = false;

            // Stop tracking loop
            if (focalPointAnimationId) {
                cancelAnimationFrame(focalPointAnimationId);
                focalPointAnimationId = null;
            }

            // Stop gamepad polling
            stopGamepadPolling();
        }

        function toggleTrackingMode() {
            if (!isSpiderModeActive) return;

            // If auto mode is active, turn it off first
            if (isAutoMode) {
                isAutoMode = false;
                if (autoModeTimeoutId) {
                    clearTimeout(autoModeTimeoutId);
                    autoModeTimeoutId = null;
                }
            }

            // Only turn on tracking mode, don't toggle off
            if (!isTrackingMode) {
                // Switch to tracking mode
                // Stop all random movement
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && eyeData.moveTimeoutId) {
                        clearTimeout(eyeData.moveTimeoutId);
                        eyeData.moveTimeoutId = null;
                    }
                }

                startFocalPointTracking();
            }
        }

        function autoToggleTracking() {
            if (!isSpiderModeActive || !isAutoMode) return;

            // Toggle tracking mode
            if (isTrackingMode) {
                // Switch to normal mode
                stopFocalPointTracking();

                // Restart random movement for all eyes
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && !eyeData.moveTimeoutId) {
                        const initialDelay = Math.random() * 1500 + 500;
                        eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(i), initialDelay);
                    }
                }
            } else {
                // Switch to tracking mode
                // Stop all random movement
                for (let i = 0; i < spiderEyes.length; i++) {
                    const eyeData = spiderEyes[i];
                    if (eyeData && eyeData.moveTimeoutId) {
                        clearTimeout(eyeData.moveTimeoutId);
                        eyeData.moveTimeoutId = null;
                    }
                }

                startFocalPointTracking();
            }

            // Schedule next toggle
            const nextToggleDelay = Math.random() * (autoModeToggleDelayMax - autoModeToggleDelayMin) + autoModeToggleDelayMin;
            autoModeTimeoutId = setTimeout(autoToggleTracking, nextToggleDelay);
        }

        function toggleAutoMode() {
            if (!isSpiderModeActive) return;

            if (isAutoMode) {
                // Turn off auto mode
                isAutoMode = false;

                // Clear auto mode timer
                if (autoModeTimeoutId) {
                    clearTimeout(autoModeTimeoutId);
                    autoModeTimeoutId = null;
                }

                // Leave current tracking state as is
            } else {
                // Turn on auto mode
                isAutoMode = true;

                // Start auto toggling
                autoToggleTracking();
            }
        }

        // Drip spawning functions
        function dripSpiderEye(eyeId) {
            if (!dripsEnabled) return;
            if (!isSpiderModeActive) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Get eye position on screen
            const rect = eyeData.element.getBoundingClientRect();

            // Spawn drip at random position along bottom of eye
            const randomXOffset = (Math.random() - 0.5) * rect.width * 0.6; // Random position along bottom
            const spawnX = rect.left + rect.width / 2 + randomXOffset;
            const spawnY = rect.bottom - 5; // Just below eye

            spawnDrip(spawnX, spawnY);

            // Schedule next drip
            const nextDripDelay = Math.random() * (dripDelayMaxSpider - dripDelayMinSpider) + dripDelayMinSpider;
            eyeData.dripTimeoutId = setTimeout(() => dripSpiderEye(eyeId), nextDripDelay);
        }

        function dripEyeSet(setIndex) {
            if (!dripsEnabled) return;
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const eyes = eyeSet.element.querySelectorAll('.eye');

            // Drip from both eyes
            eyes.forEach(eye => {
                const rect = eye.getBoundingClientRect();

                // Spawn drip at random position along bottom of eye
                const randomXOffset = (Math.random() - 0.5) * rect.width * 0.5;
                const spawnX = rect.left + rect.width / 2 + randomXOffset;
                const spawnY = rect.bottom - 10;

                spawnDrip(spawnX, spawnY);
            });

            // Schedule next drip
            const nextDripDelay = Math.random() * (dripDelayMaxNormal - dripDelayMinNormal) + dripDelayMinNormal;
            eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(setIndex), nextDripDelay);
        }

        // Spider mode functions
        function blinkSpiderEye(eyeId) {
            if (!isSpiderModeActive) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Store the current pulse animation
            const currentAnimation = eyeData.element.style.animation;

            // Apply blink animation (overrides pulse temporarily)
            eyeData.element.style.animation = 'eyeBlink 0.4s ease-in-out';

            // Restore pulse animation after blink completes
            setTimeout(() => {
                eyeData.element.style.animation = currentAnimation;
            }, 400);

            // Schedule next blink
            const nextBlinkDelay = Math.random() * (spiderEyeBlinkDelayMax - spiderEyeBlinkDelayMin) + spiderEyeBlinkDelayMin;
            eyeData.blinkTimeoutId = setTimeout(() => blinkSpiderEye(eyeId), nextBlinkDelay);
        }

        function moveSpiderEyeIris(eyeId) {
            if (!isSpiderModeActive || isTrackingMode) return;

            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            const irises = eyeData.element.querySelectorAll('.iris');

            // Generate random position within eye bounds
            const randomX = (Math.random() - 0.5) * 2 * spiderEyeIrisMaxMovement;
            const randomY = (Math.random() - 0.5) * 2 * spiderEyeIrisMaxMovement;

            // Apply movement to all iris groups
            irises.forEach(iris => {
                iris.style.transform = `translate(${randomX}px, ${randomY}px)`;
            });

            // Schedule next movement (only if not in tracking mode)
            if (!isTrackingMode) {
                const nextMoveDelay = Math.random() * (spiderEyeMoveDelayMax - spiderEyeMoveDelayMin) + spiderEyeMoveDelayMin;
                eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(eyeId), nextMoveDelay);
            }
        }

        function startSpiderEyeAnimations(eyeId) {
            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Apply pulsing animation with random duration
            const pulseDuration = Math.random() * (spiderEyePulseDurationMax - spiderEyePulseDurationMin) + spiderEyePulseDurationMin;
            eyeData.element.style.animation = `eyePulse ${pulseDuration}s infinite ease-in-out`;

            // Apply color animations with random delay
            const randomDelay = Math.random() * 60;
            const animationStyle = `colorShift 60s infinite linear ${randomDelay}s`;

            // Apply animations to iris-main elements only
            const irisMainElements = eyeData.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = animationStyle;
            });

            // Start blinking with initial random delay (1-3 seconds)
            const initialBlinkDelay = Math.random() * 2000 + 1000;
            eyeData.blinkTimeoutId = setTimeout(() => blinkSpiderEye(eyeId), initialBlinkDelay);

            // Start iris movement with initial random delay (0.5-2 seconds) - only if not in tracking mode
            if (!isTrackingMode) {
                const initialMoveDelay = Math.random() * 1500 + 500;
                eyeData.moveTimeoutId = setTimeout(() => moveSpiderEyeIris(eyeId), initialMoveDelay);
            }

            // Start dripping with initial random delay (2-5 seconds)
            const initialDripDelay = Math.random() * 3000 + 2000;
            eyeData.dripTimeoutId = setTimeout(() => dripSpiderEye(eyeId), initialDripDelay);
        }

        function stopSpiderEyeAnimations(eyeId) {
            const eyeData = spiderEyes[eyeId];
            if (!eyeData) return;

            // Clear timeout timers
            if (eyeData.blinkTimeoutId) {
                clearTimeout(eyeData.blinkTimeoutId);
                eyeData.blinkTimeoutId = null;
            }
            if (eyeData.moveTimeoutId) {
                clearTimeout(eyeData.moveTimeoutId);
                eyeData.moveTimeoutId = null;
            }
            if (eyeData.dripTimeoutId) {
                clearTimeout(eyeData.dripTimeoutId);
                eyeData.dripTimeoutId = null;
            }

            // Remove pulse animation from eye element
            eyeData.element.style.animation = '';

            // Remove color animations
            const irisMainElements = eyeData.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = '';
            });
        }

        function initializeSpiderMode() {
            const spiderStage = document.getElementById('spider-stage');

            // Create all spider eyes if not already created
            if (spiderEyes.length === 0) {
                for (let i = 0; i < spiderEyeCount; i++) {
                    const eyeElement = createSpiderEye(i);
                    spiderStage.appendChild(eyeElement);

                    // Only track visible eyes (skip hidden corner eyes)
                    if (!hiddenEyeIndices.has(i)) {
                        spiderEyes.push({
                            element: eyeElement,
                            blinkTimeoutId: null,
                            moveTimeoutId: null,
                            dripTimeoutId: null
                        });
                    }
                }
            }
        }

        function toggleSpiderMode() {
            const eyesStage = document.getElementById('eyes-stage');
            const spiderStage = document.getElementById('spider-stage');

            if (!isSpiderModeActive) {
                // Entering spider mode
                isSpiderModeActive = true;

                // Hide normal eyes
                eyesStage.classList.add('spider-mode-active');

                // Stop all normal eye animations
                for (let i = 0; i < eyeSets.length; i++) {
                    if (eyeSets[i] && eyeSets[i].visible) {
                        stopEyeSetAnimations(i);
                    }
                }

                // Initialize spider eyes if first time
                initializeSpiderMode();

                // Show spider grid
                spiderStage.classList.add('active');

                // Start all spider eye animations (only for visible eyes)
                for (let i = 0; i < spiderEyes.length; i++) {
                    startSpiderEyeAnimations(i);
                }

                // Start auto creepy mode by default
                toggleAutoMode();
            } else {
                // Exiting spider mode
                isSpiderModeActive = false;

                // Stop auto mode if active
                if (isAutoMode) {
                    isAutoMode = false;
                    if (autoModeTimeoutId) {
                        clearTimeout(autoModeTimeoutId);
                        autoModeTimeoutId = null;
                    }
                }

                // Stop tracking if active
                if (isTrackingMode) {
                    stopFocalPointTracking();
                }

                // Stop all spider eye animations (only for visible eyes)
                for (let i = 0; i < spiderEyes.length; i++) {
                    stopSpiderEyeAnimations(i);
                }

                // Hide spider grid
                spiderStage.classList.remove('active');

                // Show normal eyes
                eyesStage.classList.remove('spider-mode-active');

                // Check if any eye sets are visible
                let hasVisibleSets = false;
                for (let i = 0; i < eyeSets.length; i++) {
                    if (eyeSets[i] && eyeSets[i].visible) {
                        hasVisibleSets = true;
                        startEyeSetAnimations(i);
                    }
                }

                // If no eye sets are visible, show the first set
                if (!hasVisibleSets) {
                    toggleEyeSet(0);
                }
            }
        }

        // Per-set blinking function
        function blinkEyeSet(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const eyes = eyeSet.element.querySelectorAll('.eye');

            // Add blink class
            eyes.forEach(eye => eye.classList.add('blinking'));

            // Remove blink class after 100ms (blink duration)
            setTimeout(() => {
                eyes.forEach(eye => eye.classList.remove('blinking'));
            }, 100);

            // Only schedule next blink if still in AUTONOMOUS mode
            if (eyeSet.behavior === BehaviorType.AUTONOMOUS) {
                const nextBlinkDelay = Math.random() * 16000 + 4000; // 4000ms to 20000ms
                eyeSet.blinkTimeoutId = setTimeout(() => blinkEyeSet(setIndex), nextBlinkDelay);
            }
        }

        // Per-set iris movement function
        function moveEyeSetIris(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet || !eyeSet.visible) return;

            const irises = eyeSet.element.querySelectorAll('.iris');

            // Generate random position within eye bounds
            const maxX = 50; // Maximum horizontal movement
            const maxY = 10; // Maximum vertical movement
            const randomX = (Math.random() - 0.5) * 2 * maxX; // -50 to 50
            const randomY = (Math.random() - 0.5) * 2 * maxY; // -10 to 10

            // Apply movement to all iris groups (iris, pupil, lens flare)
            irises.forEach(iris => {
                iris.style.transform = `translate(${randomX}px, ${randomY}px)`;
            });

            // Only schedule next movement if still in AUTONOMOUS mode
            if (eyeSet.behavior === BehaviorType.AUTONOMOUS) {
                const nextMoveDelay = Math.random() * 5000 + 1000; // 1000ms to 5000ms
                eyeSet.moveTimeoutId = setTimeout(() => moveEyeSetIris(setIndex), nextMoveDelay);
            }
        }

        // Start all animations for an eye set
        function startEyeSetAnimations(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Only start autonomous animations if in AUTONOMOUS behavior mode
            if (eyeSet.behavior !== BehaviorType.AUTONOMOUS) {
                return;
            }

            // Apply color animations with random delay to desync from other sets
            const randomDelay = Math.random() * 60; // 0-60 seconds
            const animationStyle = `colorShift 60s infinite linear ${randomDelay}s`;
            const gradientAnimations = [
                `colorShift1 60s infinite linear ${randomDelay}s`,
                `colorShift2 60s infinite linear ${randomDelay}s`,
                `colorShift3 60s infinite linear ${randomDelay}s`,
                `colorShift4 60s infinite linear ${randomDelay}s`
            ];

            // Apply animations to iris-main elements
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = animationStyle;
            });

            // Apply animations to gradient stops
            const gradientStops = eyeSet.element.querySelectorAll('.iris-gradient-stop-1, .iris-gradient-stop-2, .iris-gradient-stop-3, .iris-gradient-stop-4');
            gradientStops.forEach(stop => {
                if (stop.classList.contains('iris-gradient-stop-1')) {
                    stop.style.animation = gradientAnimations[0];
                } else if (stop.classList.contains('iris-gradient-stop-2')) {
                    stop.style.animation = gradientAnimations[1];
                } else if (stop.classList.contains('iris-gradient-stop-3')) {
                    stop.style.animation = gradientAnimations[2];
                } else if (stop.classList.contains('iris-gradient-stop-4')) {
                    stop.style.animation = gradientAnimations[3];
                }
            });

            // Start blinking with initial random delay (1-3 seconds)
            const initialBlinkDelay = Math.random() * 2000 + 1000;
            eyeSet.blinkTimeoutId = setTimeout(() => blinkEyeSet(setIndex), initialBlinkDelay);

            // Start iris movement with initial random delay (0.5-2 seconds)
            const initialMoveDelay = Math.random() * 1500 + 500;
            eyeSet.moveTimeoutId = setTimeout(() => moveEyeSetIris(setIndex), initialMoveDelay);

            // Start dripping with initial random delay (1-3 seconds)
            const initialDripDelay = Math.random() * 2000 + 1000;
            eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(setIndex), initialDripDelay);
        }

        // Stop all animations for an eye set
        function stopEyeSetAnimations(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            // Clear timeout timers
            if (eyeSet.blinkTimeoutId) {
                clearTimeout(eyeSet.blinkTimeoutId);
                eyeSet.blinkTimeoutId = null;
            }
            if (eyeSet.moveTimeoutId) {
                clearTimeout(eyeSet.moveTimeoutId);
                eyeSet.moveTimeoutId = null;
            }
            if (eyeSet.dripTimeoutId) {
                clearTimeout(eyeSet.dripTimeoutId);
                eyeSet.dripTimeoutId = null;
            }

            // Remove color animations
            const irisMainElements = eyeSet.element.querySelectorAll('.iris-main');
            irisMainElements.forEach(elem => {
                elem.style.animation = '';
            });

            const gradientStops = eyeSet.element.querySelectorAll('.iris-gradient-stop-1, .iris-gradient-stop-2, .iris-gradient-stop-3, .iris-gradient-stop-4');
            gradientStops.forEach(stop => {
                stop.style.animation = '';
            });
        }

        // Stop all drips for all eyes
        function stopAllDrips() {
            // Stop drips for normal eye sets
            for (let i = 0; i < maxSets; i++) {
                const eyeSet = eyeSets[i];
                if (eyeSet && eyeSet.dripTimeoutId) {
                    clearTimeout(eyeSet.dripTimeoutId);
                    eyeSet.dripTimeoutId = null;
                }
            }

            // Stop drips for spider eyes
            if (isSpiderModeActive) {
                for (let eyeId = 0; eyeId < spiderEyes.length; eyeId++) {
                    const eyeData = spiderEyes[eyeId];
                    if (eyeData && eyeData.dripTimeoutId) {
                        clearTimeout(eyeData.dripTimeoutId);
                        eyeData.dripTimeoutId = null;
                    }
                }
            }
        }

        // Start drips for all visible eyes
        function startAllDrips() {
            // Start drips for visible normal eye sets
            for (let i = 0; i < maxSets; i++) {
                const eyeSet = eyeSets[i];
                if (eyeSet && eyeSet.visible) {
                    const initialDripDelay = Math.random() * 2000 + 1000;
                    eyeSet.dripTimeoutId = setTimeout(() => dripEyeSet(i), initialDripDelay);
                }
            }

            // Start drips for spider eyes
            if (isSpiderModeActive) {
                for (let eyeId = 0; eyeId < spiderEyes.length; eyeId++) {
                    const eyeData = spiderEyes[eyeId];
                    if (eyeData) {
                        const initialDripDelay = Math.random() * 3000 + 2000;
                        eyeData.dripTimeoutId = setTimeout(() => dripSpiderEye(eyeId), initialDripDelay);
                    }
                }
            }
        }

        // Create or get an eye set
        function getOrCreateEyeSet(setIndex) {
            if (eyeSets[setIndex]) {
                return eyeSets[setIndex];
            }

            // Create new eye set
            const container = createEyePair(setIndex);
            const state = { ...defaultState };

            eyeSets[setIndex] = {
                element: container,
                ...state,
                visible: false
            };

            document.getElementById('eyes-stage').appendChild(container);
            return eyeSets[setIndex];
        }

        // Update eye set transform
        function updateEyeSetTransform(setIndex) {
            const eyeSet = eyeSets[setIndex];
            if (!eyeSet) return;

            const { scale, posX, posY, gap } = eyeSet;
            eyeSet.element.style.transform = `translate(calc(-50% + ${posX}px), calc(-50% + ${posY}px)) scale(${scale})`;
            eyeSet.element.style.gap = `${gap}vw`;
        }

        // Save state to localStorage
        function saveStateToLocalStorage() {
            try {
                const state = {
                    eyeSets: [],
                    activeSetIndex: activeSetIndex,
                    dripsEnabled: dripsEnabled,
                    scriptExecutionState: {
                        defaultScripts: scriptExecutionState.defaultScripts
                    }
                };

                // Save only persistable properties for each eye set
                for (let i = 0; i < maxSets; i++) {
                    const eyeSet = eyeSets[i];
                    if (eyeSet) {
                        state.eyeSets[i] = {
                            scale: eyeSet.scale,
                            gap: eyeSet.gap,
                            posX: eyeSet.posX,
                            posY: eyeSet.posY,
                            visible: eyeSet.visible,
                            everShown: eyeSet.everShown,
                            behavior: eyeSet.behavior || BehaviorType.AUTONOMOUS
                        };
                    } else {
                        state.eyeSets[i] = null;
                    }
                }

                localStorage.setItem(localStorageKey, JSON.stringify(state));
            } catch (error) {
                console.error('Failed to save state to localStorage:', error);
            }
        }

        // Debounced save to avoid excessive localStorage writes
        function debouncedSaveState() {
            if (saveStateDebounceTimer) {
                clearTimeout(saveStateDebounceTimer);
            }
            saveStateDebounceTimer = setTimeout(saveStateToLocalStorage, saveStateDebounceDelay);
        }

        // Load state from localStorage
        function loadStateFromLocalStorage() {
            try {
                const savedState = localStorage.getItem(localStorageKey);
                if (!savedState) return null;

                return JSON.parse(savedState);
            } catch (error) {
                console.error('Failed to load state from localStorage:', error);
                return null;
            }
        }

        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();

            // Spacebar to toggle instructions
            if (key === ' ') {
                event.preventDefault();
                const instructions = document.getElementById('instructions');
                instructions.classList.toggle('visible');
                return;
            }

            // Z key to toggle Spider Mode
            if (key === 'z') {
                event.preventDefault();
                toggleSpiderMode();
                return;
            }

            // X key to toggle eye tracking (spider mode only)
            if (key === 'x') {
                event.preventDefault();
                toggleTrackingMode();
                return;
            }

            // C key to toggle auto mode (spider mode only)
            if (key === 'c') {
                event.preventDefault();
                toggleAutoMode();
                return;
            }

            // T key to toggle drips (tears)
            if (key === 't') {
                event.preventDefault();
                dripsEnabled = !dripsEnabled;
                if (dripsEnabled) {
                    startAllDrips();
                } else {
                    stopAllDrips();
                }
                debouncedSaveState();
                return;
            }

            // D key - toggle director on/off
            if (key === 'd') {
                event.preventDefault();
                if (directorState.enabled) {
                    stopDirector();
                } else {
                    startDirector(directorState.mode);
                }
                return;
            }

            // M key - cycle director mode (passive -> active -> chaotic)
            if (key === 'm') {
                event.preventDefault();
                if (directorState.enabled) {
                    const modes = ['passive', 'active', 'chaotic'];
                    const currentIndex = modes.indexOf(directorState.mode);
                    const nextMode = modes[(currentIndex + 1) % modes.length];
                    setDirectorMode(nextMode);
                } else {
                    console.log('Director is not enabled. Press D to start.');
                }
                return;
            }

            // B key - cycle behavior mode (autonomous -> tracking -> scripted)
            if (key === 'b') {
                event.preventDefault();
                if (activeSetIndex !== -1) {
                    cycleBehavior(activeSetIndex);
                }
                return;
            }

            // S key - cycle through available scripts
            if (key === 's') {
                event.preventDefault();
                if (activeSetIndex !== -1) {
                    // Get all loaded scripts
                    const scriptIds = Array.from(scriptExecutionState.loadedScripts.keys());
                    if (scriptIds.length === 0) {
                        console.log('No scripts loaded yet');
                        return;
                    }

                    const eyeSet = eyeSets[activeSetIndex];
                    if (eyeSet && eyeSet.behavior === BehaviorType.SCRIPTED && eyeSet.currentScript) {
                        // Already in scripted mode with a script running, cycle to next
                        cycleScript(activeSetIndex);
                    } else {
                        // Not in scripted mode or no script running, start with first script
                        const firstScript = scriptIds[0];
                        executeScript(activeSetIndex, firstScript);
                    }
                }
                return;
            }

            // P key - play default script for active eye set
            if (key === 'p') {
                event.preventDefault();
                if (activeSetIndex !== -1) {
                    const defaultScript = scriptExecutionState.defaultScripts[activeSetIndex];
                    if (defaultScript) {
                        executeScript(activeSetIndex, defaultScript);
                    } else {
                        console.log('No default script assigned to eye set ' + activeSetIndex);
                    }
                }
                return;
            }

            // Escape key - stop current script and return to autonomous
            if (key === 'escape') {
                event.preventDefault();
                if (activeSetIndex !== -1) {
                    const eyeSet = eyeSets[activeSetIndex];
                    if (eyeSet && eyeSet.currentScript) {
                        stopScript(activeSetIndex);
                    }
                }
                return;
            }

            // Arrow keys - control focal point if in tracking mode, otherwise control eye position
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();

                if (isTrackingMode) {
                    // Spider mode tracking - use fixed step movement
                    if (event.key === 'ArrowUp') {
                        moveFocalPointManually(0, -focalPointManualMoveStep);
                    } else if (event.key === 'ArrowDown') {
                        moveFocalPointManually(0, focalPointManualMoveStep);
                    } else if (event.key === 'ArrowLeft') {
                        moveFocalPointManually(-focalPointManualMoveStep, 0);
                    } else if (event.key === 'ArrowRight') {
                        moveFocalPointManually(focalPointManualMoveStep, 0);
                    }
                } else if (activeSetIndex !== -1) {
                    // Normal mode - use hold-duration quadratic acceleration
                    // Record key press timestamp (only on first press, ignore repeat events)
                    if (!heldArrowKeys[event.key]) {
                        heldArrowKeys[event.key] = Date.now();

                        // Start animation loop if not already running
                        if (!arrowKeyAnimationId) {
                            arrowKeyAnimationId = requestAnimationFrame(updateArrowKeyMovement);
                        }
                    }
                }
                return;
            }

            // Number keys 1-0 for eye set toggle (maps to sets 0-9)
            if (key >= '1' && key <= '9') {
                event.preventDefault();
                const setIndex = parseInt(key) - 1;
                toggleEyeSet(setIndex);
                return;
            } else if (key === '0') {
                event.preventDefault();
                toggleEyeSet(9); // 0 key maps to set 9
                return;
            }

            // Control keys only work if there's an active set
            if (activeSetIndex === -1) return;
            const eyeSet = eyeSets[activeSetIndex];

            // Q/W for scale (up/down)
            if (key === 'q') {
                event.preventDefault();
                eyeSet.scale = Math.min(eyeSet.scale + scaleStep, maxScale);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            } else if (key === 'w') {
                event.preventDefault();
                eyeSet.scale = Math.max(eyeSet.scale - scaleStep, minScale);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            }
            // E/R for gap (wider/closer)
            else if (key === 'e') {
                event.preventDefault();
                eyeSet.gap = Math.min(eyeSet.gap + gapStep, maxGap);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            } else if (key === 'r') {
                event.preventDefault();
                eyeSet.gap = Math.max(eyeSet.gap - gapStep, minGap);
                updateEyeSetTransform(activeSetIndex);
                debouncedSaveState();
            }
        });

        // Keyup listener to clear arrow key hold state
        document.addEventListener('keyup', (event) => {
            // Clear held arrow key when released
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                delete heldArrowKeys[event.key];

                // Stop animation loop if no keys are held
                if (Object.keys(heldArrowKeys).length === 0 && arrowKeyAnimationId) {
                    cancelAnimationFrame(arrowKeyAnimationId);
                    arrowKeyAnimationId = null;
                }
            }
        });

        // Animation loop for continuous arrow key movement with quadratic acceleration
        function updateArrowKeyMovement() {
            // Only proceed if there are held keys and an active eye set
            if (Object.keys(heldArrowKeys).length === 0 || activeSetIndex === -1) {
                arrowKeyAnimationId = null;
                return;
            }

            const now = Date.now();
            const eyeSet = eyeSets[activeSetIndex];

            // Process each held arrow key
            for (const key in heldArrowKeys) {
                const pressDuration = (now - heldArrowKeys[key]) / 1000; // Convert to seconds

                // Calculate speed using quadratic acceleration: speed = baseSpeed + acceleration * t^2
                const speed = Math.min(
                    arrowKeyBaseSpeed + arrowKeyAcceleration * pressDuration * pressDuration,
                    arrowKeyMaxSpeed
                );

                // Update position based on key direction
                if (key === 'ArrowUp') {
                    eyeSet.posY -= speed;
                } else if (key === 'ArrowDown') {
                    eyeSet.posY += speed;
                } else if (key === 'ArrowLeft') {
                    eyeSet.posX -= speed;
                } else if (key === 'ArrowRight') {
                    eyeSet.posX += speed;
                }
            }

            // Apply the position update
            updateEyeSetTransform(activeSetIndex);
            debouncedSaveState();

            // Continue animation loop
            arrowKeyAnimationId = requestAnimationFrame(updateArrowKeyMovement);
        }

        // Toggle eye set visibility and active state
        function toggleEyeSet(setIndex) {
            if (setIndex < 0 || setIndex >= maxSets) return;

            const eyeSet = getOrCreateEyeSet(setIndex);

            // If this set is active and visible, hide it
            if (activeSetIndex === setIndex && eyeSet.visible) {
                eyeSet.visible = false;
                eyeSet.element.classList.add('hidden');
                stopEyeSetAnimations(setIndex);
                debouncedSaveState();
                return;
            }

            // If this set exists but is not active, make it active
            if (!eyeSet.visible) {
                // First time showing this eye set - spawn at random location
                if (!eyeSet.everShown) {
                    const randomPos = getRandomSpawnPosition();
                    eyeSet.posX = randomPos.posX;
                    eyeSet.posY = randomPos.posY;
                    eyeSet.everShown = true;
                }

                eyeSet.visible = true;
                eyeSet.element.classList.remove('hidden');
                // Apply initial transform to center the eyes
                updateEyeSetTransform(setIndex);

                // Ensure we're in autonomous mode and start animations cleanly
                eyeSet.behavior = BehaviorType.AUTONOMOUS;
                eyeSet.lastBehaviorChange = Date.now();
                stopEyeSetAnimations(setIndex);
                startEyeSetAnimations(setIndex);
            }

            activeSetIndex = setIndex;
            debouncedSaveState();
        }

        // Gamepad event listeners
        window.addEventListener('gamepadconnected', (event) => {
            connectedGamepad = event.gamepad;
            console.log(`Gamepad connected: ${event.gamepad.id}`);
            console.log('Use left stick to control focal point in tracking mode');

            // Start polling if in tracking mode
            if (isTrackingMode) {
                startGamepadPolling();
            }
        });

        window.addEventListener('gamepaddisconnected', (event) => {
            console.log(`Gamepad disconnected: ${event.gamepad.id}`);
            connectedGamepad = null;
            stopGamepadPolling();
        });

        // Initialize first eye set on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Console message
            console.log('Press Space bar for help');

            // Initialize drip pool
            initializeDripPool();

            // Show help message on page load
            const helpMessage = document.getElementById('help-message');
            setTimeout(() => {
                helpMessage.classList.add('visible');
            }, 100); // Small delay to ensure transition works

            // Fade out after 5 seconds
            setTimeout(() => {
                helpMessage.classList.remove('visible');
            }, 5100);

            // Preload scripts
            preloadAllScripts();

            // Try to restore saved state from localStorage
            const savedState = loadStateFromLocalStorage();
            if (savedState && savedState.eyeSets) {
                // Restore script execution state
                if (savedState.scriptExecutionState) {
                    scriptExecutionState.defaultScripts = savedState.scriptExecutionState.defaultScripts || {};
                }

                // Restore eye sets from saved state
                for (let i = 0; i < maxSets; i++) {
                    const savedSet = savedState.eyeSets[i];
                    if (savedSet) {
                        // Create or get the eye set
                        const eyeSet = getOrCreateEyeSet(i);

                        // Restore saved properties
                        eyeSet.scale = savedSet.scale;
                        eyeSet.gap = savedSet.gap;
                        eyeSet.posX = savedSet.posX;
                        eyeSet.posY = savedSet.posY;
                        eyeSet.visible = savedSet.visible;
                        eyeSet.everShown = savedSet.everShown;
                        eyeSet.behavior = savedSet.behavior || BehaviorType.AUTONOMOUS;

                        // If this set was visible, show it
                        if (savedSet.visible) {
                            eyeSet.element.classList.remove('hidden');
                            updateEyeSetTransform(i);

                            // Start appropriate behavior
                            if (eyeSet.behavior === BehaviorType.TRACKING) {
                                startEyeSetTracking(i);
                            } else {
                                // Default to autonomous for other modes
                                // (scripted mode doesn't persist - scripts don't auto-play on load)
                                eyeSet.behavior = BehaviorType.AUTONOMOUS;
                                startEyeSetAnimations(i);
                            }
                        }
                    }
                }

                // Restore active set index
                activeSetIndex = savedState.activeSetIndex;

                // Restore drip toggle state (default to true if not present)
                dripsEnabled = savedState.dripsEnabled !== undefined ? savedState.dripsEnabled : true;

                console.log('Restored eye sets from localStorage');
            } else {
                // No saved state - start in spider mode by default
                toggleSpiderMode();
            }
        });
    </script>
</body>
</html>